{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-09-09T00:07:38.934044+00:00",
  "repo": "oauth-wg/draft-ietf-oauth-rfc8725bis",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDONgvdIs6lD8EI",
      "title": "Mitigation for Billion Hashes Attack",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/issues/1",
      "state": "CLOSED",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "selfissued"
      ],
      "labels": [],
      "body": "From Jesse Yang <p3ngu1nw@gmail.com>\r\n\r\nDuring our testing, nine libraries were vulnerable to the Billion Hashes Attack. The root cause of this issue is that there is no limit on the size of the p2c claim in the JWE encrypted by the PBES2 algorithm, which causes the server to run billions of hash calculations when decrypting the JWE, causing a denial of service attack. Therefore, we propose adding a warning about this threat in RFC8725 and recommending an upper limit on the size of the p2c claim to mitigate the risk.\r\n",
      "createdAt": "2025-01-05T13:22:41Z",
      "updatedAt": "2025-05-18T01:14:46Z",
      "closedAt": "2025-05-18T01:14:46Z",
      "comments": [
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "See also https://i.blackhat.com/BH-US-23/Presentations/US-23-Tervoort-Three-New-Attacks-Against-JSON-Web-Tokens.pdf",
          "createdAt": "2025-01-05T14:07:42Z",
          "updatedAt": "2025-01-05T14:07:42Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @P3ngu1nW\n",
          "createdAt": "2025-01-16T16:18:31Z",
          "updatedAt": "2025-01-16T16:18:31Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "I_kwDONgvdIs6lD8N6",
      "title": "Mitigation for JWT Format Confusion",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/issues/2",
      "state": "CLOSED",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "dickhardt"
      ],
      "labels": [],
      "body": "From Jesse Yang <p3ngu1nw@gmail.com>\r\n\r\nWe found four libraries that support JSON-type JWS when parsing JWT. If the user extracts the payload by string interception after verification, the attacker can forge the content, which leads to JWT Format Confusion. We found such an exploitation case in Openshift Telemeter (CVE-2024-5037[1]) and Kubernetes identity verification[2] that supports parsing JSON JWS and leading to authentication bypass. Therefore, we propose to include this threat in RFC8725 for systematic consideration and advise against parsing JSON JWSs.\r\n\r\n[1]: https://nvd.nist.gov/vuln/detail/cve-2024-5037\r\n[2]: https://github.com/kubernetes/kubernetes/pull/123540",
      "createdAt": "2025-01-05T13:24:15Z",
      "updatedAt": "2025-05-23T09:23:04Z",
      "closedAt": "2025-05-23T09:23:03Z",
      "comments": [
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "See also https://bugzilla.redhat.com/show_bug.cgi?id=2272339\r\n\r\nAnd \"polyglot JWS\" here: https://i.blackhat.com/BH-US-23/Presentations/US-23-Tervoort-Three-New-Attacks-Against-JSON-Web-Tokens.pdf",
          "createdAt": "2025-01-05T13:59:54Z",
          "updatedAt": "2025-01-05T13:59:54Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @P3ngu1nW\n",
          "createdAt": "2025-01-16T16:18:20Z",
          "updatedAt": "2025-01-16T16:18:20Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "https://www.rfc-editor.org/rfc/rfc7519.html#section-1 says:\n> JWTs are always   represented using the JWS Compact Serialization or the JWE Compact   Serialization.\n\nJWT parsers need to enforce this.",
          "createdAt": "2025-05-12T14:51:57Z",
          "updatedAt": "2025-05-12T14:51:57Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #11 .",
          "createdAt": "2025-05-23T09:23:03Z",
          "updatedAt": "2025-05-23T09:23:03Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDONgvdIs6lD8aL",
      "title": "Mitigation for Compression DoS",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/issues/3",
      "state": "CLOSED",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "dickhardt"
      ],
      "labels": [],
      "body": "From Jesse Yang <p3ngu1nw@gmail.com>\r\n\r\nJWE allows the payload to be compressed and then decompressed after the recipient decrypts the JWE. However, we observed that 13 libraries did not check the length of the JWE when decompressing it. This means that an attacker can encrypt a very long and malicious JWT and send it to the recipient, causing a denial of service attack. Therefore, we suggest adding this issue in RFC8725 and recommending a upper limit on the length of JWE.",
      "createdAt": "2025-01-05T13:26:15Z",
      "updatedAt": "2025-05-21T22:24:45Z",
      "closedAt": "2025-05-21T22:24:45Z",
      "comments": [
        {
          "author": "panva",
          "authorAssociation": "MEMBER",
          "body": "@P3ngu1nW and I did go through a [fix on my library a year ago](https://github.com/panva/jose/security/advisories/GHSA-hhhv-q57g-882q), https://github.com/panva/jose/commit/1b91d88d2f8233f3477a5f4579aa5f8057b2ee8b\n\nI don't believe checking for token length is the right solution, it's very crude and error prone. Instead, and that's what I've implemented, when working with compressed content it's important to set decompression output length limits. Routines responsible for decompresssion usually have such settings.\n\nThis way you're dealing with the high compression ratio part without introducing arbitrary token length limits.",
          "createdAt": "2025-01-16T15:58:47Z",
          "updatedAt": "2025-05-13T08:47:07Z"
        },
        {
          "author": "panva",
          "authorAssociation": "MEMBER",
          "body": "FWIW @b---c opted in for the same kind of mitigation in jose4j",
          "createdAt": "2025-01-16T18:59:33Z",
          "updatedAt": "2025-01-16T18:59:33Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "NONE",
          "body": "Thanks for the better memory than me, @panva. But I agree with your assessment (as I often do).  Here is the fix in my library https://bitbucket.org/b_c/jose4j/commits/19a90a64c47b - looks like I was a day before Filip with the fix :) ",
          "createdAt": "2025-01-16T20:50:31Z",
          "updatedAt": "2025-01-16T20:50:31Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "notes for @dickhardt \n\n- set a max size for decompression - 250 MB is commonly used??",
          "createdAt": "2025-05-12T14:57:10Z",
          "updatedAt": "2025-05-12T14:57:10Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "NONE",
          "body": "> notes for [@dickhardt](https://github.com/dickhardt)\n> \n>    * set a max size for decompression - 250 MB is commonly used??\n\nno, I think the commonly used limits are over one thousand times smaller than that ",
          "createdAt": "2025-05-12T15:26:47Z",
          "updatedAt": "2025-05-12T15:26:57Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "> > notes for [@dickhardt](https://github.com/dickhardt)\n> > \n> > * set a max size for decompression - 250 MB is commonly used??\n> \n> no, I think the commonly used limits are over one thousand times smaller than that\n\ndoh! -- meant KB ",
          "createdAt": "2025-05-21T01:34:19Z",
          "updatedAt": "2025-05-21T01:34:19Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDONgvdIs6lD8gR",
      "title": "Mitigation for JWS/JWE Confusion",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/issues/4",
      "state": "CLOSED",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "yaronf"
      ],
      "labels": [],
      "body": "From Jesse Yang <p3ngu1nw@gmail.com>\r\n\r\nJWT allows users to pass in JWS and JWE when parsing, but mixing these two tokens will cause security issues. During our testing, we found two libraries are vulnerable to this issue where attackers use public key encrypted JWE to bypass the parsing of JWT using asymmetric encryption algorithms. The root cause of this security issue is that the JWK implemented allows both public and private keys to be included, resulting in a bypass even if the algorithm is verified according to the method mentioned in RFC8725 3.1 (check whether the RSA algorithm is used). Therefore, we propose adding a warning about this threat in RFC8725 and advising developers not to include both public and private keys in JWK, and check the \"use\" claim in JWK before parsing JWT.",
      "createdAt": "2025-01-05T13:27:14Z",
      "updatedAt": "2025-05-23T09:21:56Z",
      "closedAt": "2025-05-23T09:21:56Z",
      "comments": [
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "See also \"sign/encrypt confusion\" here: https://i.blackhat.com/BH-US-23/Presentations/US-23-Tervoort-Three-New-Attacks-Against-JSON-Web-Tokens.pdf",
          "createdAt": "2025-01-05T14:01:17Z",
          "updatedAt": "2025-01-05T14:01:17Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @P3ngu1nW\n",
          "createdAt": "2025-01-16T16:17:59Z",
          "updatedAt": "2025-01-16T16:17:59Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm fine warning people not to publish their private keys.",
          "createdAt": "2025-04-21T14:25:35Z",
          "updatedAt": "2025-04-21T14:25:35Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm fine warning people that if they require a signature on a JWT, that they must verify that the content was signed.",
          "createdAt": "2025-04-21T14:42:10Z",
          "updatedAt": "2025-04-21T14:42:10Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": " @P3ngu1nW Do you have any references or CVEs for this vulnerability?",
          "createdAt": "2025-04-22T08:00:56Z",
          "updatedAt": "2025-04-22T08:00:56Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "https://www.cve.org/CVERecord?id=CVE-2023-51774",
          "createdAt": "2025-04-22T13:11:38Z",
          "updatedAt": "2025-04-22T13:11:38Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDONgvdIs6lD-l3",
      "title": "Key Identification guidance",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/issues/5",
      "state": "OPEN",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "selfissued"
      ],
      "labels": [],
      "body": "Now that we're reopening the JWT BCP, should we include the guidance on key identification from Hannes' draft, https://datatracker.ietf.org/doc/draft-tschofenig-jose-cose-guidance/ ?\r\n\r\nThe target audience for the drafts may be different though, with the JWT BCP targeting library authors and the \"guidance\" draft aimed at application writers.",
      "createdAt": "2025-01-05T13:48:38Z",
      "updatedAt": "2025-05-21T22:52:15Z",
      "closedAt": null,
      "comments": [
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "It would be fine to describe how the `kid` header parameter should be used to perform key identification.\r\n\r\n@hannestschofenig warns against key identification information in the payload of a JWT but doesn't give any examples of when and why this is done.  I'd like to understand the nature of the problem before talking about solutions.\r\n\r\nThat said, it's normal to use claims from the payload - in particular, the `iss` claim - in the procedure to retrieve the keys.  For instance, [Obtaining OpenID Provider Configuration Information](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig) requires appending `.well-known/openid-configuration` to the `iss` claim value in an ID Token as part of the process of retrieving the signing keys.  This is a feature - not a bug - as it guarantees that the keys belong to the issuer.\r\n\r\nOur target audience should be all kinds of developers - both library and application developers.",
          "createdAt": "2025-01-05T19:53:37Z",
          "updatedAt": "2025-01-05T19:53:37Z"
        },
        {
          "author": "hannestschofenig",
          "authorAssociation": "NONE",
          "body": "The point of the draft was the following:\n\nYou need to give the recipient some means to identify the key it has to use for verification. This is information that needs to be either explit in the JWT (or in a COSE structure in general) or implicit (typically through some other layer outside).\n\nOnce you have this information you do not need other information anymore, such as algorithm identifiers, since the recipient needs to also know (in addition to the key identifier) what algorithm to use. If the recipient does not already possess this information then there is a risk that an attacker modifies information, such as the algorithm.",
          "createdAt": "2025-04-21T16:49:53Z",
          "updatedAt": "2025-04-21T16:49:53Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "@hannestschofenig, I'm still not sure what attack you're describing or how it should be mitigated.\n\nFor instance, when the \"alg\" value is a protected header parameter, the attacker can't modify it.  This is true both for signed JWTs and encrypted JWTs using an AEAD algorithm.  The only case where it's not true is \"alg\": \"none\", which RFC 8725 already discusses.",
          "createdAt": "2025-05-12T13:54:06Z",
          "updatedAt": "2025-05-12T13:54:06Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "> That said, it's normal to use claims from the payload - in particular, the `iss` claim - in the procedure to retrieve the keys. For instance, [Obtaining OpenID Provider Configuration Information](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig) requires appending `.well-known/openid-configuration` to the `iss` claim value in an ID Token as part of the process of retrieving the signing keys. This is a feature - not a bug - as it guarantees that the keys belong to the issuer.\n\nI disagree. IMHO this is a bug: the original JOSE architecture only requires the recipient to parse the smaller/simpler header in order to validate the whole JWS.\n\nThe OIDC solution means the recipient should go through hoops instead:\n* Parse an **untrusted** JWS (which may try to exploit JSON parsing vulnerabilities) to obtain `iss`.\n* Use that value to access an **untrusted** URL to read a public key.\n* Verify the JWS.\n* If this fails, make sure to throw away the already parsed JWS, whose claims may already be cached somewhere.\n\n[CVE-2025-30144](https://nvd.nist.gov/vuln/detail/CVE-2025-30144) is a related vulnerability.\n",
          "createdAt": "2025-05-17T14:36:59Z",
          "updatedAt": "2025-05-17T14:36:59Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "> the original JOSE architecture only requires the recipient to parse the smaller/simpler header in order to validate the whole JWS.\n\nThat's not a complete description of the situation.  JWS does not define a way to know the keys or validate control of them.  Nor does JWT.  OpenID Connect ID Tokens do, for example.\n\nJWT does define claims used to validate control of the keys - especially \"iss\".  That's not a bug - it's a super-useful and widely used feature.\n\n> Parse an untrusted JWS (which may try to exploit JSON parsing vulnerabilities) to obtain iss.\n\nAll JWTs are untrusted until their integrity and issuer have been validated.  Nothing new.\n\nIf you can't parse bytes that purport to be JSON without exercising JSON parsing vulnerabilities in your code, you have bigger problems than those related to JWTs.\n\n> Use that value to access an untrusted URL to read a public key.\n\nThat the URL trustworthy is confirmed by validating the signature using a key obtained.  If the signature doesn't validate using a key obtained by the issuer, the JWT is rejected, along with any content retrieved from the URL.\n\n> If this fails, make sure to throw away the already parsed JWS, whose claims may already be cached somewhere.\n\nIf you cache claims from a rejected JWT, that's simply a code bug.",
          "createdAt": "2025-05-17T15:40:04Z",
          "updatedAt": "2025-05-17T15:40:04Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "To address this issue, we need to identify the attacks we will describe in the text and how we're mitigating them.  @hannestschofenig?\n\nUnless we identify attacks and mitigations, we should close this issue with no action.",
          "createdAt": "2025-05-21T22:52:14Z",
          "updatedAt": "2025-05-21T22:52:14Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDONgvdIs6lEAKp",
      "title": "Case sensitivity of algorithm names",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/issues/6",
      "state": "CLOSED",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "yaronf"
      ],
      "labels": [],
      "body": "See slide 11 here: https://i.blackhat.com/BH-US-23/Presentations/US-23-Tervoort-Three-New-Attacks-Against-JSON-Web-Tokens.pdf",
      "createdAt": "2025-01-05T14:03:47Z",
      "updatedAt": "2025-05-17T15:35:50Z",
      "closedAt": "2025-05-17T15:35:50Z",
      "comments": [
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "Adding references - all related to Auth0.\n\n* https://stytch.com/blog/auth0-security-incidents/\n* https://cybercx.co.nz/blog/json-web-token-validation-bypass-in-auth0-authentication-api/\n\nBTW the Stytch blog gets the issue wrong: the problem is less about the case sensitive filtering and more about normalization of the \"alg\" field which is defined as case sensitive.\n\nAlso, this is an issue in proprietary, closed software. So full implementation details are not available.",
          "createdAt": "2025-05-17T15:21:50Z",
          "updatedAt": "2025-05-17T15:21:50Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "I_kwDONgvdIs637873",
      "title": "Acknowledgements",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/issues/13",
      "state": "OPEN",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "selfissued"
      ],
      "labels": [],
      "body": "We need to acknowledge Jesse Yang @p3ngu1nw who effectively initiated the bis document.",
      "createdAt": "2025-05-23T10:34:08Z",
      "updatedAt": "2025-09-08T14:14:28Z",
      "closedAt": null,
      "comments": [
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "And maybe also Tom Tervoort who found several of these attacks.",
          "createdAt": "2025-05-23T10:36:51Z",
          "updatedAt": "2025-05-23T10:36:51Z"
        },
        {
          "author": "P3ngu1nW",
          "authorAssociation": "NONE",
          "body": "Thank you for your work on the updated JWT BCP, which further secures the JWT protocol.\nIf possible, we would be honored to be included in the acknowledgements section. In that case, please kindly list us as follows:\nJingcheng Yang(@P3ngu1nW), Mentor: Prof. Jianjun Chen(@chenjj), Collaborator: Enze Wang(@zer0yu)",
          "createdAt": "2025-05-24T02:16:06Z",
          "updatedAt": "2025-05-24T02:16:06Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "Add: Dan Moore.",
          "createdAt": "2025-07-14T20:23:19Z",
          "updatedAt": "2025-07-14T20:23:19Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "From @bc-pi:\n> Similarly it'd be good etiquette to, in the acknowledgements, distinguish between contributors to the original document and those that have contributed to the updates. I know from some github interactions, for one example, that \u2068Filip Skokan\u2069 has helped guide some of the updated text but he's not mentioned at present. \n\nSpecifically: https://github.com/yaronf/draft-sheffer-oauth-rfc8725bis/issues/3#issuecomment-2596104401",
          "createdAt": "2025-08-10T09:51:14Z",
          "updatedAt": "2025-08-10T11:12:20Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "I_kwDONgvdIs7AhT8r",
      "title": "Comments from Dan Moore",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/issues/14",
      "state": "OPEN",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "yaronf"
      ],
      "labels": [],
      "body": "- [ ] In https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#name-weak-symmetric-keys perhaps you want to mention this open source project which cracks JWTs signed with a weak HMAC key: https://github.com/brendan-rius/c-jwt-cracker\n\n- [ ] In https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#name-incorrect-use-and-compositi I'd change\n\"However verifiers don't always check that the received JWT is a signed JWS as opposed to an encrypted JWE structure.\"\nto \"However verifiers don't always check that the received JWT is a JWS (a signed JWT) as opposed to a JWE (a JWT with encrypted structure).\"\nA JWS is by definition signed, just as a JWE is by definition encrypted, so I thought this was clearer.\n\n- [ ] In https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#section-2.4 I'd change\n\"Many encryption algorithms leak information about the length of the plaintext, with a varying amount of leakage depending on the algorithm and mode of operation.\"\nto \"Many encryption algorithms leak information about the length of the plaintext, with a varying amount of leakage depending on the algorithm and mode of operation. JWEs are vulnerable to this leakage.\"\nAlternatively you could add other language to make it clear this attack is applicable to JWEs, not JWTs in general, just as is done in https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#section-2.12 . I suppose you could even change the section header to \"JWE Plaintext Leakage through Analysis of Ciphertext Length\". In general there are a few security issues that are related to encryption and therefore only affect JWEs.\n\n- [ ] In https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#section-2.5\nThe Sanso link is busted (expired cert, 404 for https://blogs.adobe.com/security/2017/03/critical-vulnerability-uncovered-in-json-encryption.html ) so you might want to review.\n\n- [ ] Is the attack outlined here https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#section-2.5 the same as\nhttps://neilmadden.blog/2022/04/19/psychic-signatures-in-java/ ? If so, maybe that is a better link?\n\n- [ ] In https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#section-2.8 I'd change\n\"As JWTs are being used by more different protocols in diverse application areas, it becomes increasingly important to prevent cases of JWT tokens that have been issued for one purpose being subverted and used for another.\"\nTo \"As JWTs are used by more protocols in diverse ways, it becomes increasingly important to prevent JWT tokens that have been issued for one purpose being used for another.\"\nJust think it reads cleaner.\n\n- [ ] In https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#section-3.1-2 I'd change\n\"In particular, use allowlists for critical parameters such as \"alg\" instead of blocklists.\"\n\"In particular, libraries SHOULD use allowlists for critical parameters such as \"alg\" instead of blocklists.\"\nThis makes it a complete sentence.\n\n- [ ] In https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#section-3.2 you quote the RFC which mentions SHOULD but then you follow it up with MUST. I find that confusing. I'd remove the first paragraph or at least this sentence: \"Even if a JWS can be successfully validated, unless the algorithm(s) used in the JWS are acceptable to the application, it SHOULD consider the JWS to be invalid.\" because then you remove the SHOULD/MUST confusion I had.\n\n- [ ] In that same section, the semi-colon was awkward. I'd change\n\"JWTs using \"none\" are often used in application contexts in which the content is optionally signed; then, the URL-safe claims representation and processing can be the same in both the signed and unsigned cases.\"\nto\n\"JWTs using \"none\" are often used in application contexts in which the content is optionally signed. The URL-safe claims representation and processing in this context can be the same in both the signed and unsigned cases.\"\n\n- [ ] In https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#section-3.3 I'd change\n\"Libraries MUST allow the verifier to distinguish between JWS-signed and JWE-encrypted JWTs. This would allow verifiers to easily establish a policy of only accepting JWS-signed JWTs.\"\nto\n\"Libraries MUST allow the verifier to distinguish between signed JWTs (JWSes) and encrypted JWTs (JWEs). This allows verifiers to easily establish a policy of only accepting signed JWTs.\"\nI found the terms JWS-signed and JWT-encrypted confusing. They felt internally redundant (a JWS is always signed, for example).\n\n- [ ] In https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#section-3.6 I wondered if it made sense to mention JWEs here? Maybe change\n\"Compression of data SHOULD NOT be done before encryption, because such compressed data often reveals information about the plaintext.\"\nto \n\"Compression of data SHOULD NOT be used when creating a JWE, because such compressed data often reveals information about the plaintext.\"\nThis distinguishes between JWS and JWE, where the latter is the only one this recommendation applies to.\n\n- [ ] In https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#section-3.7 I'd change\n\"Implementations and applications MUST do this and not use or admit the use of other Unicode encodings for these purposes.\"\nto\n\"Implementations and applications MUST do this and not use or allow the use of other Unicode encodings for these purposes.\"\nUnless \"admit\" means something special in this context, \"allow\" is clearer. \"allow\" seems more common and \"admit\" is not used elsewhere in this doc.\n\n- [ ] In https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#section-3.9 I worry about changes to the implementation (where you start with one RP/app, then add more). I'd address this by adding a clause about the future:\n\"If the same issuer can issue JWTs that are intended for use by more than one relying party or application\"\nto\n\"If the same issuer can issue JWTs that are intended for use by more than one relying party or application, or may in the future,\"\n\n- [ ] I'd also change\n\"or was substituted by an attacker at an unintended party.\"\nto\n\"or was substituted by an attacker.\"\nI'm not sure what the \"unintended party\" phrase adds.\n\n- [ ] There's also this sentence:\n\"In such cases, the relying party or application MUST validate the audience value, and if the audience value is not present or not associated with the recipient, it MUST reject the JWT.\"\nThe aud claim can be an array https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.3 . Should we mention that here? Maybe something like:\n\"In such cases, the relying party or application MUST validate the audience value, and if no audience value is present or none of the values are associated with the recipient, it MUST reject the JWT.\"\n\n- [ ] I found https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#section-3.11-2 confusing.  Here's the text:\n\"Per the definition of \"typ\" in Section 4.1.9 of [RFC7515], it is RECOMMENDED that the \"application/\" prefix be omitted from the \"typ\" value. Therefore, for example, the \"typ\" value used to explicitly include a type for a SET SHOULD be \"secevent+jwt\". When explicit typing is employed for a JWT, it is RECOMMENDED that a media type name of the format \"application/example+jwt\" be used, where \"example\" is replaced by the identifier for the specific kind of JWT.\"\nAs a JWT creator, should I be including \"application/\" in the typ value? I see recommendations for and against that, unless the media type name refers to something other than the value of the typ header. What am I missing?\n\n- [ ] In https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#section-3.12 I missed the MUST here, as I jumped right to the list. I'd suggest a small formatting change to highlight the MUST. Can we do a newline to make it clearer? That would change:\n\"If more than one kind of JWT can be issued by the same issuer, the validation rules for those JWTs MUST be written such that they are mutually exclusive, rejecting JWTs of the wrong kind. To prevent substitution of JWTs from one context into another, application developers may employ a number of strategies:\"\nto\n\"If more than one kind of JWT can be issued by the same issuer, the validation rules for those JWTs MUST be written such that they are mutually exclusive, rejecting JWTs of the wrong kind. To prevent substitution of JWTs from one context into another, application developers may employ a number of strategies:\"\n\n- [ ] In https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#section-3.13\nthat 600k OWASP iteration recommendation value changes over time. Do you want this text to be more broadly applicable in the future? (Not sure how this kind of thing is handled in general.) If so, could change this from:\n\"\"[OWASP-Password-Storage] states that an iteration count of 600,000 is required when using HMAC-SHA-256 to achieve FIPS-140 compliance. Thus, rejecting inputs with a p2c (PBES2 Count) value over 1,200,000 (double that) is RECOMMENDED.\"\nto\n\"[OWASP-Password-Storage] states a specific iteration count (600,000 at time of publishing) is required when using HMAC-SHA-256 to achieve FIPS-140 compliance. Rejecting inputs with a p2c (PBES2 Count) value larger than double the recommended OWASP value is RECOMMENDED.\"\n\n- [ ] In https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#section-3.14 it is unclear to me if this if this is for the JWT as encoded or the decoded value? I think encoded, but am not sure. Do you want to reference base64 url encoding here? as mentioned in 7515 and by https://datatracker.ietf.org/doc/html/rfc4648#section-5\n\ncc: @mooreds",
      "createdAt": "2025-07-14T20:30:33Z",
      "updatedAt": "2025-07-16T17:31:29Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 15,
      "id": "I_kwDONgvdIs7AqFcH",
      "title": "JWTs issued for one individual must not be usable by another individual with a complicity between these individuals",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/issues/15",
      "state": "OPEN",
      "author": "Denisthemalice",
      "authorAssociation": "NONE",
      "assignees": [
        "dickhardt"
      ],
      "labels": [],
      "body": "The title of this document is JSON Web Token Best Current Practices. Its goal is \"to provide actionable guidance leading to secure implementation and deployment of JWTs\" and \"to facilitate *secure implementation* and deployment of JWTs\" (Introduction).\n\nSection 2 (Threats and Vulnerabilities) lists some known and possible problems with JWT implementations and deployments. \n\nSection 2.7 (Substitution Attacks) states:\n\n> There are attacks in which one recipient will be given a JWT that was intended for it and will attempt to use it at a different recipient for which that JWT was not intended.\n\nThis relates to the audience of the JWT.\n\nSection 2.8 (Cross-JWT Confusion) states:\n\n> As JWTs are being used by more different protocols in diverse application areas, it becomes increasingly important to prevent cases of JWT tokens that have been issued for one purpose being subverted and used for another. \n\n\nThe concept of \"purpose\" is inexistent in JWT-SD and would need to be clarified.\n\nThis draft is concentrating on the structure of JWTs, but is ignoring the context in which JWTs are requested, obtained and then used. \n\nSD-JWTs defined SD-JWTs *formats* for two flows: \n\n     a) when an issuer issues a SD-JWT including all Disclosures,\n     b) when a verifier presents SD-JWT or SD-JWT+KB including selected Disclosures.\n\nHowever, SD-JWT does not define which *protocols* can be used to carry these *data formats*.\n\nHence, threats and vulnerabilities that can arise in these protocols are not considered, nor addressed. \nThis means that the current content of this draft while explicit targeted to \"Developers of specifications that rely on JWTs, \nboth inside and **outside the IETF**\" is incomplete.\n\nTwo important \"specifications that rely on JWTs outside the IETF\" are:\n\n> \"OID4VCI\": OpenID for Verifiable Credential Issuance - draft 16\n> https://openid.net/specs/openid-4-verifiable-credential-issuance-1_0.html\n> \n> \"OID4VP\": \"OpenID for Verifiable Presentations 1.0\" which defines a protocol for requesting and presenting Credentials (published on 9 July 2025). It defines a mechanism on top of OAuth 2.0 to allow presentation of claims in the form of Verifiable Credentials as part of the protocol flow. https://openid.net/specs/openid-4-verifiable-presentations-1_0.html\n\nThese two OpenID specifications contain many optional features. This makes difficult for implementers to select a right combination that allows to develop a secure implementation.\n\nWhen using selective disclosure of claims, it is important to prevent cases where JWTs issued for one individual would be usable by another individual with a complicity between these individuals. In some cases, this issue is identified as a \"relay attack\".\n\nThis issue has not been identified in the documents produced by the OAuth WG (nor the SPICE WG), nor in OID4VP.\n\nOID4VP defines protocols for requesting and presenting Credentials. It is not explicitly said that these protocols must be supported by a single application and that the end-user using the device supporting that application SHALL NOT be able to modify it or to use its \"key store\" by downloading a rogue application and then using these keys with it.\n\nOnce this issue is identified, it needs to be addressed in a section called \"implementation considerations\" which, unfortunately, is inexistent in the proposed draft.\n\nThis topic is highly dependent upon the type of the device, however, general considerations apply.\n\n\n",
      "createdAt": "2025-07-15T13:25:23Z",
      "updatedAt": "2025-09-08T14:14:11Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 17,
      "id": "I_kwDONgvdIs7Dv4RM",
      "title": "Review by Aaron Parecki",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/issues/17",
      "state": "OPEN",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "yaronf"
      ],
      "labels": [],
      "body": "- [ ] One application area in which JWTs are commonly used is representing digital identity information, such as OpenID Connect ID Tokens  [OpenID.Core] and OAuth 2.0  [RFC6749] access tokens and refresh tokens\n\n    Change to \"representing authorization or identity information, such as\nOAuth 2.0 access tokens [RFC9068] and OpenID Connect ID Tokens\n[OpenID.Core]\"\n\n    It is not common practice to use JWTs for refresh tokens, since\nrefresh tokens are only consumed by the issuer, whereas access tokens\nare consumed by the resource server which is a separate role from the\nauthorization server that issues them. Also updated the reference to\nthe JWT access token spec.\n\n- [ ] if a JWT is cryptographically protected end-to-end by a transport layer, such as TLS using cryptographically current algorithms, there may be no need to apply another layer of cryptographic protections to the JWT. In such cases, the use of the \"none\" algorithm can be perfectly acceptable.\n\n    This makes it sound like it's acceptable to send alg none JWTs as\naccess tokens over TLS, which is obviously not true. I would suggest\nremoving all references to alg none being acceptable. If there is an\nactual concrete use case for alg none JWTs, list it out explicitly,\npreferably to a reference of a spec/profile that uses it.\n\n- [ ] Section 3.3 mentions the term \"Nested JWT\" capitalized, but this is\nthe first occurrence of the term in the document. Add a reference to\nwhere Nested JWT is defined, or change to lowercase if the intent is\nto mention the general concept of nested JWTs.\n\n- [ ] The means of determining the keys owned by an issuer is application-specific. As one example, OpenID Connect  [OpenID.Core] issuer values are \"https\" URLs that reference a JSON metadata document that contains a \"jwks_uri\" value that is an \"https\" URL from which the issuer's keys are retrieved as a JWK Set [RFC7517]. This same mechanism is used by  [RFC8414].\n\n- [ ] Swap the mentions of RFC8414 and OpenID Connect: \"As one example,\nAuthorization Server Metadata [RFC8414] issuer values are .... The\nsame mechanism is used by OpenID Connect [OpenID.Core].\"\n\n- [ ] Similarly, when the JWT contains a \"sub\" (subject) claim, the application MUST validate that the subject value corresponds to a valid subject and/or issuer-subject pair at the application\n\n    This would benefit from an explicit reference to Section 4.15 of\nRFC9700 https://datatracker.ietf.org/doc/html/rfc9700#section-4.15\nwhich talks about the possibility of client_id vs user identifier\nconfusion.\n\n- [ ] Section 3.10: change \"whitelist\" to \"allowlist\". There is already a\nprior use of \"allowlist\" in the doc, so I assume this was\nunintentional.\n\n- [ ] Also in section 3.10, mention that the AS should check what the\nhostname resolves to and avoid making a request if it resolves to a\nloopback or internal IP address. (e.g. someone uses the value\n\"attacker.example.com/etc/passwd\" as the jwks_uri, but adds a DNS\nentry for \"attacker.example.com\" to resolve to \"127.0.0.1\" or other\ninternal IP address ranges.\n\n- [ ] Section 3.11: \"Sometimes, one kind of JWT can be confused for another.\"\n\n    This is kind of vague and would benefit from more explicit examples.\n\nCC: @aaronpk",
      "createdAt": "2025-08-01T14:18:38Z",
      "updatedAt": "2025-09-08T14:15:45Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 18,
      "id": "I_kwDONgvdIs7FIwoP",
      "title": "Need a \"Changes from RFC8725\" section",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/issues/18",
      "state": "OPEN",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "selfissued"
      ],
      "labels": [],
      "body": "The doc history section is insufficient, and is not published with the RFC.",
      "createdAt": "2025-08-10T09:52:37Z",
      "updatedAt": "2025-09-08T14:16:35Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 19,
      "id": "I_kwDONgvdIs7HqdTX",
      "title": "Representation of time values to void the 2038 bug",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/issues/19",
      "state": "OPEN",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "yaronf"
      ],
      "labels": [],
      "body": "Per ChatGPT, this is not a problem in mainstream systems, but remains a real problem in IOT. Quoting:\n\nShort answer: in mainstream server/client JOSE stacks, **no**\u2014current libraries do **not** use 32-bit integers for `NumericDate`. But in **embedded** ecosystems you can still encounter effective 32-bit limits because the platform\u2019s `time_t` (or equivalent) is 32-bit, and some Arduino/RTOS JWT implementations inherit that.\n\n### What I can confirm today\n\n* **Embedded/RTOS platforms still ship 32-bit `time_t`.** For example, Arduino environments and ESP8266 builds commonly use 32-bit (often signed) `time_t`, which overflows in 2038. ([[Arduino Forum](https://forum.arduino.cc/t/combining-int-and-time-t/907182?utm_source=chatgpt.com)][1], [[GitHub](https://github.com/esp8266/Arduino/issues/4948?utm_source=chatgpt.com)][2])\n* **JWT libraries exist for those platforms.** Several Arduino JWT libraries target AVR/ESP-class boards (which therefore inherit the 32-bit epoch limit unless they store timestamps in a wider type). ([[GitHub](https://github.com/Ant2000/CustomJWT?utm_source=chatgpt.com)][3], [[about.gitlab.com](https://gitlab.com/petrhu/ArduinoJWT/blob/master/examples/simple_JSON_jwt/simple_JSON_jwt.ino?utm_source=chatgpt.com)][4])\n* **Some projects still file bugs about 32-bit time usage.** The Zephyr RTOS had an open issue around use of 32-bit `time_t`. ([[GitHub](https://github.com/zephyrproject-rtos/zephyr/issues/58681?utm_source=chatgpt.com)][5])\n\n### Mainstream stacks (generally safe)\n\nModern general-purpose platforms use 64-bit time or IEEE-754 doubles for JSON numbers:\n\n* **Windows/MSVC** defaults `time_t` to 64-bit; 32-bit can be forced but is discouraged because it breaks after Jan 18, 2038. ([[Microsoft Learn](https://learn.microsoft.com/en-us/previous-versions/1f4c8f33%28v%3Dvs.140%29?utm_source=chatgpt.com)][6])\n* Historical bugs in popular JWT libs (e.g., using Java `Integer` for dates) were fixed years ago to use 64-bit `Long`. ([[GitHub](https://github.com/auth0/java-jwt/issues/132?utm_source=chatgpt.com)][7])\n\n### Practical guidance\n\n* If you\u2019re using **Arduino/ESP/RTOS** JWT code, **audit** how it parses/serializes `exp/nbf/iat`: confirm it uses a 64-bit type (or a double) end-to-end, not `time_t`/`long` that is 32-bit on that target.\n* In \\*\\*Java/C#/**Node/Python**, you\u2019re typically safe, but unit-test with a token whose `exp` is beyond **2038-01-19** to catch regressions.\n* If you control the schema, consider allowing **fractional seconds** (per RFC 7519\u2019s allowance) to encourage use of floating-point/64-bit representations.\n\n**Bottom line:** Current, maintained JOSE/JWT libraries for desktop/server use do not intentionally use 32-bit `NumericDate`, but **embedded implementations can still be constrained to 32-bit by their platform**, so review those carefully. ([[Arduino Forum](https://forum.arduino.cc/t/combining-int-and-time-t/907182?utm_source=chatgpt.com)][1], [[GitHub](https://github.com/esp8266/Arduino/issues/4948?utm_source=chatgpt.com)][2])\n\n[1]: https://forum.arduino.cc/t/combining-int-and-time-t/907182?utm_source=chatgpt.com \"Combining int and time_t - Programming - Arduino Forum\"\n[2]: https://github.com/esp8266/Arduino/issues/4948?utm_source=chatgpt.com \"time_t typedef should be unsigned 32-bit (to avoid year 2038 problem)\"\n[3]: https://github.com/Ant2000/CustomJWT?utm_source=chatgpt.com \"GitHub - Ant2000/CustomJWT\"\n[4]: https://gitlab.com/petrhu/ArduinoJWT/blob/master/examples/simple_JSON_jwt/simple_JSON_jwt.ino?utm_source=chatgpt.com \"examples/simple_JSON_jwt/simple_JSON_jwt.ino \u00b7 master \u00b7 Petr ...\"\n[5]: https://github.com/zephyrproject-rtos/zephyr/issues/58681?utm_source=chatgpt.com \"[Coverity CID: 316011] Use of 32-bit time_t in lib/os/timeutil.c ...\"\n[6]: https://learn.microsoft.com/en-us/previous-versions/1f4c8f33%28v%3Dvs.140%29?utm_source=chatgpt.com \"time, _time32, _time64 | Microsoft Learn\"\n[7]: https://github.com/auth0/java-jwt/issues/132?utm_source=chatgpt.com \"Timestamps are limited by Integer/int to 2038-01-19T04:14:07 ... - GitHub\"",
      "createdAt": "2025-08-24T18:46:46Z",
      "updatedAt": "2025-09-08T14:30:43Z",
      "closedAt": null,
      "comments": [
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "https://www.rfc-editor.org/rfc/rfc8259#section-6 says:\n\n> Note that when such software is used, numbers that are integers and\n> are in the range [-(2**53)+1, (2**53)-1] are interoperable in the\n> sense that implementations will agree exactly on their numeric\n> values.\n\nSo this isn't a problem for JSON - which is what the spec uses.  We should say that.",
          "createdAt": "2025-09-08T14:26:34Z",
          "updatedAt": "2025-09-08T14:26:34Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDONgvdIs7Ik8Fd",
      "title": "Markdown magic",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/issues/20",
      "state": "CLOSED",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Add a `venue` section to the YAML at the top of the doc, as well as:\n\n```\n{::boilerplate bcp14-tagged}\n```\nin the Conventions section.",
      "createdAt": "2025-08-29T01:27:23Z",
      "updatedAt": "2025-09-08T14:32:49Z",
      "closedAt": "2025-09-08T14:32:49Z",
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 7,
      "id": "PR_kwDONgvdIs6TU96R",
      "title": "Case insensitivity",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/pull/7",
      "state": "MERGED",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This issue is mentioned in several sources but I couldn't find a good reference or a CVE.\r\n\r\nCloses #6.",
      "createdAt": "2025-04-21T17:55:18Z",
      "updatedAt": "2025-05-17T15:35:59Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "baseRefName": "main",
      "baseRefOid": "a77673ae22b8366274c42e04a44145217725f1ec",
      "headRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "headRefName": "ys-6",
      "headRefOid": "009db6d17b81040c8bf7cb8cca14aa72baf265a6",
      "closedAt": "2025-05-17T15:35:49Z",
      "mergedAt": "2025-05-17T15:35:49Z",
      "mergedBy": "yaronf",
      "mergeCommit": {
        "oid": "7e104a7798e8d375382967df02ca275e328dbebf"
      },
      "comments": [
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "The bug is not that there is a blacklist.  The bug is that case-insensitive comparisons were used.  The fix should be about that.",
          "createdAt": "2025-05-12T12:59:29Z",
          "updatedAt": "2025-05-12T12:59:29Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "> The bug is not that there is a blacklist. The bug is that case-insensitive comparisons were used. The fix should be about that.\r\n\r\nI agree on the principle. The value \"noNE\" should not be accepted by the library as a valid algorithm. But this was probably a problem in the JSON parser that was overeager to normalize JSON claims. As such it may be outside the JOSE library's control.  The mitigation is a proposed way to harden the library against such unknown issues.",
          "createdAt": "2025-05-17T15:29:55Z",
          "updatedAt": "2025-05-17T15:29:55Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDONgvdIs6l0ZYO",
          "commit": {
            "abbreviatedOid": "b7a8513"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-21T18:35:25Z",
          "updatedAt": "2025-04-21T18:35:25Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "If we're going to use the term \"blocklist\", we either need to define it or add a reference for it, as it's not a commonly understood term.  I would suggest rewording to not use the term, as that may result in text that's easier to read.",
              "createdAt": "2025-04-21T18:35:25Z",
              "updatedAt": "2025-04-21T18:35:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6l0Z_v",
          "commit": {
            "abbreviatedOid": "b7a8513"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-21T18:36:57Z",
          "updatedAt": "2025-04-21T18:36:58Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "The term \"Security Policy\" will mean different things than intended to some readers.\r\n\r\nMaybe change the title to something more like \"Algorithm Verification Code Not Defensively Written\".",
              "createdAt": "2025-04-21T18:36:58Z",
              "updatedAt": "2025-04-21T18:36:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6pxgyB",
          "commit": {
            "abbreviatedOid": "009db6d"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-05-17T15:30:36Z",
          "updatedAt": "2025-05-17T15:30:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 8,
      "id": "PR_kwDONgvdIs6TcKyL",
      "title": "Encryption/signature confusion",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/pull/8",
      "state": "MERGED",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #4.",
      "createdAt": "2025-04-22T13:27:00Z",
      "updatedAt": "2025-05-23T09:21:55Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "baseRefName": "main",
      "baseRefOid": "6ed92926d8726fa357eb1d62aba88e1945520d73",
      "headRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "headRefName": "ys-4",
      "headRefOid": "de175a4f5afaa5190f907f219a06fca0ca6e8ae2",
      "closedAt": "2025-05-23T09:21:55Z",
      "mergedAt": "2025-05-23T09:21:55Z",
      "mergedBy": "yaronf",
      "mergeCommit": {
        "oid": "41f1359749ae6ab35b87f45ebdf8003b4713e801"
      },
      "comments": [
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "> if you're accepting a JWE, you also need a private key in the JWK to decrypt the thing. So the attack (sending a JWE instead of a JWS) only works if there's a private key on the receiver's side.\r\n\r\nIt's true that the recipient needs a private key to decrypt the encrypted JWT.  But it's not true that the private key needs to be in the JWK.  Typically only the public keys would be in the JWK.  The private key would normally be privately held by the recipient - not published in a JWK.",
          "createdAt": "2025-05-17T15:47:44Z",
          "updatedAt": "2025-05-17T15:47:44Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "> > if you're accepting a JWE, you also need a private key in the JWK to decrypt the thing. So the attack (sending a JWE instead of a JWS) only works if there's a private key on the receiver's side.\r\n> \r\n> It's true that the recipient needs a private key to decrypt the encrypted JWT. But it's not true that the private key needs to be in the JWK. Typically only the public keys would be in the JWK. The private key would normally be privately held by the recipient - not published in a JWK.\r\n\r\nFirst, I'm quoting the researcher who reported the issue in #4. For more detail see slides 17-19 [here](https://i.blackhat.com/BH-US-23/Presentations/US-23-Tervoort-Three-New-Attacks-Against-JSON-Web-Tokens.pdf).\r\n\r\nAlso, the point is not that the private key is published along with the JWK, but that when the JWK is used locally in the receiver's call to the JOSE library, in includes the private key.",
          "createdAt": "2025-05-17T21:58:24Z",
          "updatedAt": "2025-05-17T21:58:24Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "Please add a history entry for this change.",
          "createdAt": "2025-05-21T22:43:23Z",
          "updatedAt": "2025-05-21T22:43:23Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "> Also, the point is not that the private key is published along with the JWK, but that when the JWK is used locally in the receiver's call to the JOSE library, in includes the private key.\r\n\r\nJWK is a format for a key. Libraries also take PEM format for the key as well -> 'JWK' is not a correct way to refer to the key -- not that it matters for this PR ",
          "createdAt": "2025-05-22T00:18:50Z",
          "updatedAt": "2025-05-22T00:49:27Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDONgvdIs6o3laS",
          "commit": {
            "abbreviatedOid": "0389dda"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-12T13:02:42Z",
          "updatedAt": "2025-05-12T13:02:43Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "```suggestion\r\nLibraries MUST allow the verifier to distinguish between JWS-signed and JWE-encrypted JWTs, enabling callers to accept only JWTs that meet their security criteria.\r\n```",
              "createdAt": "2025-05-12T13:02:42Z",
              "updatedAt": "2025-05-12T13:02:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6o40RM",
          "commit": {
            "abbreviatedOid": "0389dda"
          },
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-12T14:32:01Z",
          "updatedAt": "2025-05-12T14:32:01Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "That would allow the verifier to only accept JWS, if that's their policy.",
              "createdAt": "2025-05-12T14:32:01Z",
              "updatedAt": "2025-05-12T14:32:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6o42ec",
          "commit": {
            "abbreviatedOid": "0389dda"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-12T14:34:50Z",
          "updatedAt": "2025-05-12T14:34:50Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "```suggestion\r\n```\r\n\r\nThis is unrelated to the other changes in this PR.  Please remove it.\r\n\r\nThis also contradicts https://www.rfc-editor.org/rfc/rfc7519.html#section-11.2.",
              "createdAt": "2025-05-12T14:34:50Z",
              "updatedAt": "2025-05-12T14:42:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6o45j-",
          "commit": {
            "abbreviatedOid": "0389dda"
          },
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-12T14:38:49Z",
          "updatedAt": "2025-05-12T14:38:50Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "Move into a separate PR.\r\n\r\nThis would contradict https://www.rfc-editor.org/rfc/rfc7519.html#section-11.2",
              "createdAt": "2025-05-12T14:38:50Z",
              "updatedAt": "2025-05-12T14:41:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6pxabG",
          "commit": {
            "abbreviatedOid": "0389dda"
          },
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-17T14:48:27Z",
          "updatedAt": "2025-05-17T14:48:27Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "For the record, the following in RFC 7519 convinced me:\r\n\r\n> Note that potential concerns about security issues related to the order of signing and encryption operations are already addressed by the underlying JWS and JWE specifications; in particular, because JWE **only supports the use of authenticated encryption algorithms**, cryptographic concerns about the potential need to sign after encryption that apply in many contexts do not apply to this specification.",
              "createdAt": "2025-05-17T14:48:27Z",
              "updatedAt": "2025-05-17T14:48:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6pxf-K",
          "commit": {
            "abbreviatedOid": "bd1f190"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-17T15:27:28Z",
          "updatedAt": "2025-05-17T15:27:28Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "I don't understand what the phrase \"when the verifier's asymmetric key includes the private key\" is getting at.  How does this relate to the vulnerability?",
              "createdAt": "2025-05-17T15:27:28Z",
              "updatedAt": "2025-05-17T15:27:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6pxgJB",
          "commit": {
            "abbreviatedOid": "bd1f190"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-17T15:28:01Z",
          "updatedAt": "2025-05-17T15:28:02Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "```suggestion\r\nIn the more complicated use cases where confidentiality is required, some libraries that decrypt a JWE-encrypted JWT to obtain a JWS-signed object\r\n```",
              "createdAt": "2025-05-17T15:28:02Z",
              "updatedAt": "2025-05-17T15:28:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6pxiMv",
          "commit": {
            "abbreviatedOid": "bd1f190"
          },
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-17T15:41:01Z",
          "updatedAt": "2025-05-17T15:41:02Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "On the receiver side, if all you want is a JWS then you only need a public key in the JWK, to verify the signature.\r\n\r\nBut if you're accepting a JWE, you also need a private key in the JWK to decrypt the thing. So the attack (sending a JWE instead of a JWS) only works if there's a private key on the receiver's side.",
              "createdAt": "2025-05-17T15:41:01Z",
              "updatedAt": "2025-05-17T15:41:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6px1mf",
          "commit": {
            "abbreviatedOid": "782fb02"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-17T22:14:01Z",
          "updatedAt": "2025-05-17T22:14:02Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\nMost authentication use cases only require a simple signed JWT as their token. However verifiers don't always check that the received JWT is a signed JWS as opposed to an encrypted JWE structure. This can result in vulnerabilities when the verifier's library does not distinguish between successful decryption and successful signature validation {{CVE-2023-51774}}.\r\n```\r\n\r\nDelete the ambiguous phrase",
              "createdAt": "2025-05-17T22:14:01Z",
              "updatedAt": "2025-05-17T22:14:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qbPDv",
          "commit": {
            "abbreviatedOid": "782fb02"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-21T22:22:56Z",
          "updatedAt": "2025-05-21T22:22:56Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Please apply my suggestion deleting the ambiguous phrase, then I will approve.",
              "createdAt": "2025-05-21T22:22:56Z",
              "updatedAt": "2025-05-21T22:22:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qcC5Q",
          "commit": {
            "abbreviatedOid": "de175a4"
          },
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-05-22T00:53:59Z",
          "updatedAt": "2025-05-22T18:53:48Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "> in particular when the verifier's asymmetric key includes the private key\r\n\r\nI think I know what this means -- but I think it can be more crisp.\r\n```suggestion\r\nMost authentication use cases only require a simple signed JWT as their token. However verifiers don't always check that the received JWT is a signed JWS as opposed to an encrypted JWE structure. This can result in vulnerabilities, in particular when the verifier asymmetric key material includes both a public key and a private key, and when the verifier's library does not distinguish between successful decryption and successful signature validation {{CVE-2023-51774}}.\r\n```",
              "createdAt": "2025-05-22T00:53:59Z",
              "updatedAt": "2025-05-22T18:53:48Z"
            },
            {
              "originalPosition": 21,
              "body": "I provided a more crisp phrase -- I hope!",
              "createdAt": "2025-05-22T00:54:33Z",
              "updatedAt": "2025-05-22T18:53:48Z"
            },
            {
              "originalPosition": 21,
              "body": "I'm also fine with Mike's phrasing ... ",
              "createdAt": "2025-05-22T18:52:49Z",
              "updatedAt": "2025-05-22T18:53:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qoRHO",
          "commit": {
            "abbreviatedOid": "de175a4"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-05-22T22:13:42Z",
          "updatedAt": "2025-05-22T22:13:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 9,
      "id": "PR_kwDONgvdIs6V1wo7",
      "title": "Reject unreasonably large \"p2c\" values",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/pull/9",
      "state": "MERGED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #1 ",
      "createdAt": "2025-05-12T13:33:45Z",
      "updatedAt": "2025-05-18T01:14:45Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "baseRefName": "main",
      "baseRefOid": "7e104a7798e8d375382967df02ca275e328dbebf",
      "headRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "headRefName": "mbj-p2c",
      "headRefOid": "fc8840a620791bf1486466bd334a7ee512ffd52c",
      "closedAt": "2025-05-18T01:14:45Z",
      "mergedAt": "2025-05-18T01:14:45Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "e624354927ac64871ba37a948891449791daf824"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONgvdIs6o5Cip",
          "commit": {
            "abbreviatedOid": "2a37ab4"
          },
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-12T14:47:37Z",
          "updatedAt": "2025-05-12T14:47:37Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "1M?\r\n\r\nhttps://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html",
              "createdAt": "2025-05-12T14:47:37Z",
              "updatedAt": "2025-05-12T14:47:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6pxR4T",
          "commit": {
            "abbreviatedOid": "af7a71e"
          },
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-05-17T12:29:19Z",
          "updatedAt": "2025-05-17T12:29:19Z",
          "comments": []
        },
        {
          "id": "PRR_kwDONgvdIs6pxrfq",
          "commit": {
            "abbreviatedOid": "2a37ab4"
          },
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-17T18:46:12Z",
          "updatedAt": "2025-05-17T18:46:12Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "I thought 1M was what was recommended as well -- is 10,000 too low?",
              "createdAt": "2025-05-17T18:46:12Z",
              "updatedAt": "2025-05-17T18:46:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6pxrlt",
          "commit": {
            "abbreviatedOid": "2a37ab4"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-17T18:48:14Z",
          "updatedAt": "2025-05-17T18:48:14Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "You're looking at outdated text.  Look at the files changed.  It's now 1.2M - double the NIST value.",
              "createdAt": "2025-05-17T18:48:14Z",
              "updatedAt": "2025-05-17T18:48:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6pyDNd",
          "commit": {
            "abbreviatedOid": "af7a71e"
          },
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-05-18T00:08:08Z",
          "updatedAt": "2025-05-18T00:08:23Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "I am looking at the files changed -- at least I think I am! If 1.2M then I'm fine. ",
              "createdAt": "2025-05-18T00:08:09Z",
              "updatedAt": "2025-05-18T00:08:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 10,
      "id": "PR_kwDONgvdIs6W-pJd",
      "title": "Mitigation for Compression DoS #3",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/pull/10",
      "state": "MERGED",
      "author": "dickhardt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "yaronf",
        "selfissued"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2025-05-21T02:04:15Z",
      "updatedAt": "2025-05-21T22:24:26Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "baseRefName": "main",
      "baseRefOid": "e624354927ac64871ba37a948891449791daf824",
      "headRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "headRefName": "Mitigation-for-Compression-DoS-#3",
      "headRefOid": "4f5f1478a28ecc2278d1f0f563bf649d7e3b0b5a",
      "closedAt": "2025-05-21T22:24:26Z",
      "mergedAt": "2025-05-21T22:24:26Z",
      "mergedBy": "dickhardt",
      "mergeCommit": {
        "oid": "6ed92926d8726fa357eb1d62aba88e1945520d73"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONgvdIs6qTP7J",
          "commit": {
            "abbreviatedOid": "79e83f0"
          },
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-21T10:28:55Z",
          "updatedAt": "2025-05-21T10:28:55Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Wrong RFC number, didn't check the section number.",
              "createdAt": "2025-05-21T10:28:55Z",
              "updatedAt": "2025-05-21T10:28:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qaxRi",
          "commit": {
            "abbreviatedOid": "4f5f147"
          },
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-05-21T21:15:21Z",
          "updatedAt": "2025-05-21T21:15:21Z",
          "comments": []
        },
        {
          "id": "PRR_kwDONgvdIs6qbNBL",
          "commit": {
            "abbreviatedOid": "4f5f147"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-05-21T22:16:15Z",
          "updatedAt": "2025-05-21T22:16:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 11,
      "id": "PR_kwDONgvdIs6W-xZP",
      "title": "Mitigation for JWT Format Confusion #2",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/pull/11",
      "state": "MERGED",
      "author": "dickhardt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "yaronf",
        "selfissued"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2025-05-21T02:29:15Z",
      "updatedAt": "2025-05-22T18:50:34Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "baseRefName": "main",
      "baseRefOid": "6ed92926d8726fa357eb1d62aba88e1945520d73",
      "headRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "headRefName": "Mitigation-for-JWT-Format-Confusion-#2",
      "headRefOid": "b66067420a6291a03f421debb09924fdeeab4f99",
      "closedAt": "2025-05-22T18:50:34Z",
      "mergedAt": "2025-05-22T18:50:34Z",
      "mergedBy": "dickhardt",
      "mergeCommit": {
        "oid": "8ef55aac26eeaaf99bf65ec66d7576ed35c5cf90"
      },
      "comments": [
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "@yaronf does Mike's suggestion (which I accepted resolve your concern?",
          "createdAt": "2025-05-21T22:29:11Z",
          "updatedAt": "2025-05-21T22:29:11Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "Please add a history entry for this change.",
          "createdAt": "2025-05-21T22:42:50Z",
          "updatedAt": "2025-05-21T22:42:50Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "> @yaronf does Mike's suggestion (which I accepted resolve your concern?\r\n\r\nYes it does.",
          "createdAt": "2025-05-22T05:34:53Z",
          "updatedAt": "2025-05-22T05:34:53Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDONgvdIs6qUfAP",
          "commit": {
            "abbreviatedOid": "b384f7d"
          },
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2025-05-21T12:20:02Z",
          "updatedAt": "2025-05-21T14:39:58Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I think we should mention that JSON Serialization is not compliant with the RFC. (To be clear, we should still mention it because it happens in reality).",
              "createdAt": "2025-05-21T12:20:02Z",
              "updatedAt": "2025-05-21T14:39:58Z"
            },
            {
              "originalPosition": 20,
              "body": "RECOMMENDED means SHOULD. Why not make it a MUST?",
              "createdAt": "2025-05-21T14:39:04Z",
              "updatedAt": "2025-05-21T14:39:58Z"
            },
            {
              "originalPosition": 20,
              "body": "```suggestion\r\nImplementations are RECOMMENDED to confirm if the JWT is a supported format before parsing the JWT. If the implementation only supports the compact format, the token will start with 'e' (ASCII 0x65) and if the implementation supports the JSON format, the token will start with '{' (ASCII 0x7B). \r\n```",
              "createdAt": "2025-05-21T14:39:45Z",
              "updatedAt": "2025-05-21T14:39:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qZbg4",
          "commit": {
            "abbreviatedOid": "b384f7d"
          },
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-21T18:47:09Z",
          "updatedAt": "2025-05-21T18:47:09Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I thought JSON serialization was a valid format. No?",
              "createdAt": "2025-05-21T18:47:09Z",
              "updatedAt": "2025-05-21T18:47:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qayQB",
          "commit": {
            "abbreviatedOid": "c2a21e8"
          },
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2025-05-21T21:17:28Z",
          "updatedAt": "2025-05-21T21:20:32Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "```suggestion\r\nImplementations MUST confirm that the JWT is a supported format before parsing the JWT. If the implementation only supports the compact format, the token will start with 'e' (ASCII 0x65) and if the implementation supports the JSON format, the token will start with '{' (ASCII 0x7B).\r\n```",
              "createdAt": "2025-05-21T21:17:28Z",
              "updatedAt": "2025-05-21T21:20:32Z"
            },
            {
              "originalPosition": 6,
              "body": "Quoting RFC 7519: \"JWTs are always represented using the JWS Compact Serialization or the JWE Compact Serialization.\"",
              "createdAt": "2025-05-21T21:20:23Z",
              "updatedAt": "2025-05-21T21:20:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qbPiM",
          "commit": {
            "abbreviatedOid": "b384f7d"
          },
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-21T22:24:05Z",
          "updatedAt": "2025-05-21T22:24:06Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "While 7519 defines a JWT and that it is the compact serialization, 7515 (JWS) and 7516 (JWE) both define a compact and JSON serialization, and the attack was a library that would take both of those serializations, which sortof makes sense as they are both defined in 7515 and 7516.\r\n\r\nhttps://datatracker.ietf.org/doc/html/rfc7515#section-7\r\n\r\nhttps://datatracker.ietf.org/doc/html/rfc7516#section-7\r\n\r\n@selfissued what are your thoughts?\r\n\r\n",
              "createdAt": "2025-05-21T22:24:05Z",
              "updatedAt": "2025-05-21T22:24:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qbQ3R",
          "commit": {
            "abbreviatedOid": "c2a21e8"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-21T22:26:51Z",
          "updatedAt": "2025-05-21T22:26:52Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nSome JWS implementations support both the Compact and JSON Serializations. While JWTs MUST use the Compact Serialization, if an application by mistake verifies a JWT using the JSON Serialization but extracts claims by parsing it as a JWT using the Compact Serialization (e.g., via string splitting), an attacker can craft a valid JSON JWS with a forged payload. This mismatch in format handling can lead to authentication bypass or impersonation.\r\n```",
              "createdAt": "2025-05-21T22:26:52Z",
              "updatedAt": "2025-05-21T22:26:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qbaX1",
          "commit": {
            "abbreviatedOid": "c2a21e8"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-21T22:39:44Z",
          "updatedAt": "2025-05-21T22:39:44Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "```suggestion\r\nImplementations MUST confirm the JWT is in a legal format while parsing it. Legal JWTs contain only the ASCII characters for letters, numbers, dash, underscore, and period.  Content with any other characters - especially braces and quotation marks - is not a JWT and MUST be rejected.\r\n```\r\n\r\nJWTs don't have to start with an \"e\" if there is leading space in the JSON before base64url-encoding.  Similarly, content using the JWS JSON Serialization doesn't have to start with \"{\" because it can have leading spaces.",
              "createdAt": "2025-05-21T22:39:44Z",
              "updatedAt": "2025-05-21T22:41:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qbdP4",
          "commit": {
            "abbreviatedOid": "b385151"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-21T22:46:32Z",
          "updatedAt": "2025-05-21T22:46:32Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "```suggestion\r\nImplementations MUST confirm the JWT is in a legal format while parsing it. Legal JWTs contain only the ASCII characters for letters, numbers, dash, underscore, and period.  Content with any other characters - especially braces and quotation marks - is not a JWT and MUST be rejected.\r\n```\r\n\r\nBecause of leading spaces being legal in JSON, neither of the \"e\" nor \"{\" statements is true.",
              "createdAt": "2025-05-21T22:46:32Z",
              "updatedAt": "2025-05-21T22:46:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qbdeQ",
          "commit": {
            "abbreviatedOid": "b384f7d"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-21T22:47:26Z",
          "updatedAt": "2025-05-21T22:47:26Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "My thoughts are in my change suggestion about JWTs containing only letters, numbers, dash, underscore, and period.",
              "createdAt": "2025-05-21T22:47:26Z",
              "updatedAt": "2025-05-21T22:47:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qb3Xk",
          "commit": {
            "abbreviatedOid": "c2a21e8"
          },
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T00:14:28Z",
          "updatedAt": "2025-05-22T00:14:28Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "That is a better check, thanks Mike.",
              "createdAt": "2025-05-22T00:14:28Z",
              "updatedAt": "2025-05-22T00:14:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qdaVt",
          "commit": {
            "abbreviatedOid": "b660674"
          },
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-05-22T05:35:07Z",
          "updatedAt": "2025-05-22T05:35:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 12,
      "id": "PR_kwDONgvdIs6XW2qK",
      "title": "Add missing items to doc history",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/pull/12",
      "state": "MERGED",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-05-23T09:36:27Z",
      "updatedAt": "2025-05-23T09:37:10Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "baseRefName": "main",
      "baseRefOid": "41f1359749ae6ab35b87f45ebdf8003b4713e801",
      "headRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "headRefName": "ys-hist-01",
      "headRefOid": "4bf8fc717549f569487786aed2fb095712e21ba6",
      "closedAt": "2025-05-23T09:37:09Z",
      "mergedAt": "2025-05-23T09:37:09Z",
      "mergedBy": "yaronf",
      "mergeCommit": {
        "oid": "639b52266ab174c41e750077f4193d362592e485"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 16,
      "id": "PR_kwDONgvdIs6fLXBt",
      "title": "Obsoletes RFC 8725",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/pull/16",
      "state": "MERGED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-07-16T12:35:25Z",
      "updatedAt": "2025-07-23T10:47:18Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "baseRefName": "main",
      "baseRefOid": "639b52266ab174c41e750077f4193d362592e485",
      "headRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "headRefName": "mbj-obsoletes",
      "headRefOid": "7e0e636e9c193fa166af19452689d76327883e1f",
      "closedAt": "2025-07-23T10:47:18Z",
      "mergedAt": "2025-07-23T10:47:18Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "300fa621e57ea9ccc6526404bef1358ae6d65bc6"
      },
      "comments": [
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "@selfissued IIRC, we're also supposed to say (in the intro?) why this obsoletes the RFC. Or does this only apply to \"Updates\"?",
          "createdAt": "2025-07-16T13:03:45Z",
          "updatedAt": "2025-07-16T13:03:45Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "I think you're correct, Yaron.  I believe that in IESG reviews, I've been asked to add this kind of information to the abstract before.\r\n\r\nI'll update the PR to do so.",
          "createdAt": "2025-07-16T13:12:20Z",
          "updatedAt": "2025-07-16T13:12:20Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDONgvdIs60UZNF",
          "commit": {
            "abbreviatedOid": "7e0e636"
          },
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-16T14:14:10Z",
          "updatedAt": "2025-07-16T14:14:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 21,
      "id": "PR_kwDONgvdIs6mKLVJ",
      "title": "Venue info and boilerplate directive",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/pull/21",
      "state": "MERGED",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Close #20 \r\n\r\n- Add venue section to YAML header with working group information\r\n- Replace manual BCP14 boilerplate text with {::boilerplate bcp14-tagged} directive\r\n- This implements the markdown magic requested in GitHub issue #20",
      "createdAt": "2025-08-31T12:23:23Z",
      "updatedAt": "2025-09-08T14:32:48Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "baseRefName": "main",
      "baseRefOid": "0f83811ec8a815d0998f7383825b8c5107dce279",
      "headRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "headRefName": "ys-20",
      "headRefOid": "094c81c9974c4bb6955e11c7b77e7b746736e807",
      "closedAt": "2025-09-08T14:32:48Z",
      "mergedAt": "2025-09-08T14:32:48Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "c214a94738d9b84bbb22616c96651d175fde3395"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONgvdIs6-i6ms",
          "commit": {
            "abbreviatedOid": "094c81c"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-09-08T14:31:54Z",
          "updatedAt": "2025-09-08T14:31:54Z",
          "comments": []
        },
        {
          "id": "PRR_kwDONgvdIs6-i7Fy",
          "commit": {
            "abbreviatedOid": "094c81c"
          },
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-09-08T14:32:26Z",
          "updatedAt": "2025-09-08T14:32:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 22,
      "id": "PR_kwDONgvdIs6mKNrI",
      "title": "New section: changes from RFC 8725",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/pull/22",
      "state": "OPEN",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #18 ",
      "createdAt": "2025-08-31T12:39:38Z",
      "updatedAt": "2025-09-08T14:34:34Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "baseRefName": "main",
      "baseRefOid": "0f83811ec8a815d0998f7383825b8c5107dce279",
      "headRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "headRefName": "ys-18",
      "headRefOid": "2989a62888883ab9ba58262ea949712343ac8ea0",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONgvdIs6-i7qn",
          "commit": {
            "abbreviatedOid": "2989a62"
          },
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-09-08T14:33:05Z",
          "updatedAt": "2025-09-08T14:33:05Z",
          "comments": []
        },
        {
          "id": "PRR_kwDONgvdIs6-i9KX",
          "commit": {
            "abbreviatedOid": "2989a62"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Let's add references to all the sections with the new content.",
          "createdAt": "2025-09-08T14:34:34Z",
          "updatedAt": "2025-09-08T14:34:34Z",
          "comments": []
        }
      ]
    }
  ]
}