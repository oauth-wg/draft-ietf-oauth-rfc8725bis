{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-05-22T00:57:15.502170+00:00",
  "repo": "yaronf/draft-sheffer-oauth-rfc8725bis",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDONgvdIs6lD8EI",
      "title": "Mitigation for Billion Hashes Attack",
      "url": "https://github.com/yaronf/draft-sheffer-oauth-rfc8725bis/issues/1",
      "state": "CLOSED",
      "author": "yaronf",
      "authorAssociation": "OWNER",
      "assignees": [
        "selfissued"
      ],
      "labels": [],
      "body": "From Jesse Yang <p3ngu1nw@gmail.com>\r\n\r\nDuring our testing, nine libraries were vulnerable to the Billion Hashes Attack. The root cause of this issue is that there is no limit on the size of the p2c claim in the JWE encrypted by the PBES2 algorithm, which causes the server to run billions of hash calculations when decrypting the JWE, causing a denial of service attack. Therefore, we propose adding a warning about this threat in RFC8725 and recommending an upper limit on the size of the p2c claim to mitigate the risk.\r\n",
      "createdAt": "2025-01-05T13:22:41Z",
      "updatedAt": "2025-05-18T01:14:46Z",
      "closedAt": "2025-05-18T01:14:46Z",
      "comments": [
        {
          "author": "yaronf",
          "authorAssociation": "OWNER",
          "body": "See also https://i.blackhat.com/BH-US-23/Presentations/US-23-Tervoort-Three-New-Attacks-Against-JSON-Web-Tokens.pdf",
          "createdAt": "2025-01-05T14:07:42Z",
          "updatedAt": "2025-01-05T14:07:42Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "OWNER",
          "body": "cc @P3ngu1nW\n",
          "createdAt": "2025-01-16T16:18:31Z",
          "updatedAt": "2025-01-16T16:18:31Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "I_kwDONgvdIs6lD8N6",
      "title": "Mitigation for JWT Format Confusion",
      "url": "https://github.com/yaronf/draft-sheffer-oauth-rfc8725bis/issues/2",
      "state": "OPEN",
      "author": "yaronf",
      "authorAssociation": "OWNER",
      "assignees": [
        "dickhardt"
      ],
      "labels": [],
      "body": "From Jesse Yang <p3ngu1nw@gmail.com>\r\n\r\nWe found four libraries that support JSON-type JWS when parsing JWT. If the user extracts the payload by string interception after verification, the attacker can forge the content, which leads to JWT Format Confusion. We found such an exploitation case in Openshift Telemeter (CVE-2024-5037[1]) and Kubernetes identity verification[2] that supports parsing JSON JWS and leading to authentication bypass. Therefore, we propose to include this threat in RFC8725 for systematic consideration and advise against parsing JSON JWSs.\r\n\r\n[1]: https://nvd.nist.gov/vuln/detail/cve-2024-5037\r\n[2]: https://github.com/kubernetes/kubernetes/pull/123540",
      "createdAt": "2025-01-05T13:24:15Z",
      "updatedAt": "2025-05-12T14:51:58Z",
      "closedAt": null,
      "comments": [
        {
          "author": "yaronf",
          "authorAssociation": "OWNER",
          "body": "See also https://bugzilla.redhat.com/show_bug.cgi?id=2272339\r\n\r\nAnd \"polyglot JWS\" here: https://i.blackhat.com/BH-US-23/Presentations/US-23-Tervoort-Three-New-Attacks-Against-JSON-Web-Tokens.pdf",
          "createdAt": "2025-01-05T13:59:54Z",
          "updatedAt": "2025-01-05T13:59:54Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "OWNER",
          "body": "cc @P3ngu1nW\n",
          "createdAt": "2025-01-16T16:18:20Z",
          "updatedAt": "2025-01-16T16:18:20Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "https://www.rfc-editor.org/rfc/rfc7519.html#section-1 says:\n> JWTs are always   represented using the JWS Compact Serialization or the JWE Compact   Serialization.\n\nJWT parsers need to enforce this.",
          "createdAt": "2025-05-12T14:51:57Z",
          "updatedAt": "2025-05-12T14:51:57Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDONgvdIs6lD8aL",
      "title": "Mitigation for Compression DoS",
      "url": "https://github.com/yaronf/draft-sheffer-oauth-rfc8725bis/issues/3",
      "state": "CLOSED",
      "author": "yaronf",
      "authorAssociation": "OWNER",
      "assignees": [
        "dickhardt"
      ],
      "labels": [],
      "body": "From Jesse Yang <p3ngu1nw@gmail.com>\r\n\r\nJWE allows the payload to be compressed and then decompressed after the recipient decrypts the JWE. However, we observed that 13 libraries did not check the length of the JWE when decompressing it. This means that an attacker can encrypt a very long and malicious JWT and send it to the recipient, causing a denial of service attack. Therefore, we suggest adding this issue in RFC8725 and recommending a upper limit on the length of JWE.",
      "createdAt": "2025-01-05T13:26:15Z",
      "updatedAt": "2025-05-21T22:24:45Z",
      "closedAt": "2025-05-21T22:24:45Z",
      "comments": [
        {
          "author": "panva",
          "authorAssociation": "NONE",
          "body": "@P3ngu1nW and I did go through a [fix on my library a year ago](https://github.com/panva/jose/security/advisories/GHSA-hhhv-q57g-882q), https://github.com/panva/jose/commit/1b91d88d2f8233f3477a5f4579aa5f8057b2ee8b\n\nI don't believe checking for token length is the right solution, it's very crude and error prone. Instead, and that's what I've implemented, when working with compressed content it's important to set decompression output length limits. Routines responsible for decompresssion usually have such settings.\n\nThis way you're dealing with the high compression ratio part without introducing arbitrary token length limits.",
          "createdAt": "2025-01-16T15:58:47Z",
          "updatedAt": "2025-05-13T08:47:07Z"
        },
        {
          "author": "panva",
          "authorAssociation": "NONE",
          "body": "FWIW @b---c opted in for the same kind of mitigation in jose4j",
          "createdAt": "2025-01-16T18:59:33Z",
          "updatedAt": "2025-01-16T18:59:33Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "NONE",
          "body": "Thanks for the better memory than me, @panva. But I agree with your assessment (as I often do).  Here is the fix in my library https://bitbucket.org/b_c/jose4j/commits/19a90a64c47b - looks like I was a day before Filip with the fix :) ",
          "createdAt": "2025-01-16T20:50:31Z",
          "updatedAt": "2025-01-16T20:50:31Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "notes for @dickhardt \n\n- set a max size for decompression - 250 MB is commonly used??",
          "createdAt": "2025-05-12T14:57:10Z",
          "updatedAt": "2025-05-12T14:57:10Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "NONE",
          "body": "> notes for [@dickhardt](https://github.com/dickhardt)\n> \n>    * set a max size for decompression - 250 MB is commonly used??\n\nno, I think the commonly used limits are over one thousand times smaller than that ",
          "createdAt": "2025-05-12T15:26:47Z",
          "updatedAt": "2025-05-12T15:26:57Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "> > notes for [@dickhardt](https://github.com/dickhardt)\n> > \n> > * set a max size for decompression - 250 MB is commonly used??\n> \n> no, I think the commonly used limits are over one thousand times smaller than that\n\ndoh! -- meant KB ",
          "createdAt": "2025-05-21T01:34:19Z",
          "updatedAt": "2025-05-21T01:34:19Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDONgvdIs6lD8gR",
      "title": "Mitigation for JWS/JWE Confusion",
      "url": "https://github.com/yaronf/draft-sheffer-oauth-rfc8725bis/issues/4",
      "state": "OPEN",
      "author": "yaronf",
      "authorAssociation": "OWNER",
      "assignees": [
        "yaronf"
      ],
      "labels": [],
      "body": "From Jesse Yang <p3ngu1nw@gmail.com>\r\n\r\nJWT allows users to pass in JWS and JWE when parsing, but mixing these two tokens will cause security issues. During our testing, we found two libraries are vulnerable to this issue where attackers use public key encrypted JWE to bypass the parsing of JWT using asymmetric encryption algorithms. The root cause of this security issue is that the JWK implemented allows both public and private keys to be included, resulting in a bypass even if the algorithm is verified according to the method mentioned in RFC8725 3.1 (check whether the RSA algorithm is used). Therefore, we propose adding a warning about this threat in RFC8725 and advising developers not to include both public and private keys in JWK, and check the \"use\" claim in JWK before parsing JWT.",
      "createdAt": "2025-01-05T13:27:14Z",
      "updatedAt": "2025-04-22T13:11:39Z",
      "closedAt": null,
      "comments": [
        {
          "author": "yaronf",
          "authorAssociation": "OWNER",
          "body": "See also \"sign/encrypt confusion\" here: https://i.blackhat.com/BH-US-23/Presentations/US-23-Tervoort-Three-New-Attacks-Against-JSON-Web-Tokens.pdf",
          "createdAt": "2025-01-05T14:01:17Z",
          "updatedAt": "2025-01-05T14:01:17Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "OWNER",
          "body": "cc @P3ngu1nW\n",
          "createdAt": "2025-01-16T16:17:59Z",
          "updatedAt": "2025-01-16T16:17:59Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm fine warning people not to publish their private keys.",
          "createdAt": "2025-04-21T14:25:35Z",
          "updatedAt": "2025-04-21T14:25:35Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm fine warning people that if they require a signature on a JWT, that they must verify that the content was signed.",
          "createdAt": "2025-04-21T14:42:10Z",
          "updatedAt": "2025-04-21T14:42:10Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "OWNER",
          "body": " @P3ngu1nW Do you have any references or CVEs for this vulnerability?",
          "createdAt": "2025-04-22T08:00:56Z",
          "updatedAt": "2025-04-22T08:00:56Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "OWNER",
          "body": "https://www.cve.org/CVERecord?id=CVE-2023-51774",
          "createdAt": "2025-04-22T13:11:38Z",
          "updatedAt": "2025-04-22T13:11:38Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDONgvdIs6lD-l3",
      "title": "Key Identification guidance",
      "url": "https://github.com/yaronf/draft-sheffer-oauth-rfc8725bis/issues/5",
      "state": "OPEN",
      "author": "yaronf",
      "authorAssociation": "OWNER",
      "assignees": [
        "selfissued"
      ],
      "labels": [],
      "body": "Now that we're reopening the JWT BCP, should we include the guidance on key identification from Hannes' draft, https://datatracker.ietf.org/doc/draft-tschofenig-jose-cose-guidance/ ?\r\n\r\nThe target audience for the drafts may be different though, with the JWT BCP targeting library authors and the \"guidance\" draft aimed at application writers.",
      "createdAt": "2025-01-05T13:48:38Z",
      "updatedAt": "2025-05-21T22:52:15Z",
      "closedAt": null,
      "comments": [
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "It would be fine to describe how the `kid` header parameter should be used to perform key identification.\r\n\r\n@hannestschofenig warns against key identification information in the payload of a JWT but doesn't give any examples of when and why this is done.  I'd like to understand the nature of the problem before talking about solutions.\r\n\r\nThat said, it's normal to use claims from the payload - in particular, the `iss` claim - in the procedure to retrieve the keys.  For instance, [Obtaining OpenID Provider Configuration Information](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig) requires appending `.well-known/openid-configuration` to the `iss` claim value in an ID Token as part of the process of retrieving the signing keys.  This is a feature - not a bug - as it guarantees that the keys belong to the issuer.\r\n\r\nOur target audience should be all kinds of developers - both library and application developers.",
          "createdAt": "2025-01-05T19:53:37Z",
          "updatedAt": "2025-01-05T19:53:37Z"
        },
        {
          "author": "hannestschofenig",
          "authorAssociation": "NONE",
          "body": "The point of the draft was the following:\n\nYou need to give the recipient some means to identify the key it has to use for verification. This is information that needs to be either explit in the JWT (or in a COSE structure in general) or implicit (typically through some other layer outside).\n\nOnce you have this information you do not need other information anymore, such as algorithm identifiers, since the recipient needs to also know (in addition to the key identifier) what algorithm to use. If the recipient does not already possess this information then there is a risk that an attacker modifies information, such as the algorithm.",
          "createdAt": "2025-04-21T16:49:53Z",
          "updatedAt": "2025-04-21T16:49:53Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "@hannestschofenig, I'm still not sure what attack you're describing or how it should be mitigated.\n\nFor instance, when the \"alg\" value is a protected header parameter, the attacker can't modify it.  This is true both for signed JWTs and encrypted JWTs using an AEAD algorithm.  The only case where it's not true is \"alg\": \"none\", which RFC 8725 already discusses.",
          "createdAt": "2025-05-12T13:54:06Z",
          "updatedAt": "2025-05-12T13:54:06Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "OWNER",
          "body": "> That said, it's normal to use claims from the payload - in particular, the `iss` claim - in the procedure to retrieve the keys. For instance, [Obtaining OpenID Provider Configuration Information](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig) requires appending `.well-known/openid-configuration` to the `iss` claim value in an ID Token as part of the process of retrieving the signing keys. This is a feature - not a bug - as it guarantees that the keys belong to the issuer.\n\nI disagree. IMHO this is a bug: the original JOSE architecture only requires the recipient to parse the smaller/simpler header in order to validate the whole JWS.\n\nThe OIDC solution means the recipient should go through hoops instead:\n* Parse an **untrusted** JWS (which may try to exploit JSON parsing vulnerabilities) to obtain `iss`.\n* Use that value to access an **untrusted** URL to read a public key.\n* Verify the JWS.\n* If this fails, make sure to throw away the already parsed JWS, whose claims may already be cached somewhere.\n\n[CVE-2025-30144](https://nvd.nist.gov/vuln/detail/CVE-2025-30144) is a related vulnerability.\n",
          "createdAt": "2025-05-17T14:36:59Z",
          "updatedAt": "2025-05-17T14:36:59Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "> the original JOSE architecture only requires the recipient to parse the smaller/simpler header in order to validate the whole JWS.\n\nThat's not a complete description of the situation.  JWS does not define a way to know the keys or validate control of them.  Nor does JWT.  OpenID Connect ID Tokens do, for example.\n\nJWT does define claims used to validate control of the keys - especially \"iss\".  That's not a bug - it's a super-useful and widely used feature.\n\n> Parse an untrusted JWS (which may try to exploit JSON parsing vulnerabilities) to obtain iss.\n\nAll JWTs are untrusted until their integrity and issuer have been validated.  Nothing new.\n\nIf you can't parse bytes that purport to be JSON without exercising JSON parsing vulnerabilities in your code, you have bigger problems than those related to JWTs.\n\n> Use that value to access an untrusted URL to read a public key.\n\nThat the URL trustworthy is confirmed by validating the signature using a key obtained.  If the signature doesn't validate using a key obtained by the issuer, the JWT is rejected, along with any content retrieved from the URL.\n\n> If this fails, make sure to throw away the already parsed JWS, whose claims may already be cached somewhere.\n\nIf you cache claims from a rejected JWT, that's simply a code bug.",
          "createdAt": "2025-05-17T15:40:04Z",
          "updatedAt": "2025-05-17T15:40:04Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "To address this issue, we need to identify the attacks we will describe in the text and how we're mitigating them.  @hannestschofenig?\n\nUnless we identify attacks and mitigations, we should close this issue with no action.",
          "createdAt": "2025-05-21T22:52:14Z",
          "updatedAt": "2025-05-21T22:52:14Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDONgvdIs6lEAKp",
      "title": "Case sensitivity of algorithm names",
      "url": "https://github.com/yaronf/draft-sheffer-oauth-rfc8725bis/issues/6",
      "state": "CLOSED",
      "author": "yaronf",
      "authorAssociation": "OWNER",
      "assignees": [
        "yaronf"
      ],
      "labels": [],
      "body": "See slide 11 here: https://i.blackhat.com/BH-US-23/Presentations/US-23-Tervoort-Three-New-Attacks-Against-JSON-Web-Tokens.pdf",
      "createdAt": "2025-01-05T14:03:47Z",
      "updatedAt": "2025-05-17T15:35:50Z",
      "closedAt": "2025-05-17T15:35:50Z",
      "comments": [
        {
          "author": "yaronf",
          "authorAssociation": "OWNER",
          "body": "Adding references - all related to Auth0.\n\n* https://stytch.com/blog/auth0-security-incidents/\n* https://cybercx.co.nz/blog/json-web-token-validation-bypass-in-auth0-authentication-api/\n\nBTW the Stytch blog gets the issue wrong: the problem is less about the case sensitive filtering and more about normalization of the \"alg\" field which is defined as case sensitive.\n\nAlso, this is an issue in proprietary, closed software. So full implementation details are not available.",
          "createdAt": "2025-05-17T15:21:50Z",
          "updatedAt": "2025-05-17T15:21:50Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 7,
      "id": "PR_kwDONgvdIs6TU96R",
      "title": "Case insensitivity",
      "url": "https://github.com/yaronf/draft-sheffer-oauth-rfc8725bis/pull/7",
      "state": "MERGED",
      "author": "yaronf",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "This issue is mentioned in several sources but I couldn't find a good reference or a CVE.\r\n\r\nCloses #6.",
      "createdAt": "2025-04-21T17:55:18Z",
      "updatedAt": "2025-05-17T15:35:59Z",
      "baseRepository": "yaronf/draft-sheffer-oauth-rfc8725bis",
      "baseRefName": "main",
      "baseRefOid": "a77673ae22b8366274c42e04a44145217725f1ec",
      "headRepository": "yaronf/draft-sheffer-oauth-rfc8725bis",
      "headRefName": "ys-6",
      "headRefOid": "009db6d17b81040c8bf7cb8cca14aa72baf265a6",
      "closedAt": "2025-05-17T15:35:49Z",
      "mergedAt": "2025-05-17T15:35:49Z",
      "mergedBy": "yaronf",
      "mergeCommit": {
        "oid": "7e104a7798e8d375382967df02ca275e328dbebf"
      },
      "comments": [
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "The bug is not that there is a blacklist.  The bug is that case-insensitive comparisons were used.  The fix should be about that.",
          "createdAt": "2025-05-12T12:59:29Z",
          "updatedAt": "2025-05-12T12:59:29Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "OWNER",
          "body": "> The bug is not that there is a blacklist. The bug is that case-insensitive comparisons were used. The fix should be about that.\r\n\r\nI agree on the principle. The value \"noNE\" should not be accepted by the library as a valid algorithm. But this was probably a problem in the JSON parser that was overeager to normalize JSON claims. As such it may be outside the JOSE library's control.  The mitigation is a proposed way to harden the library against such unknown issues.",
          "createdAt": "2025-05-17T15:29:55Z",
          "updatedAt": "2025-05-17T15:29:55Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDONgvdIs6l0ZYO",
          "commit": {
            "abbreviatedOid": "b7a8513"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-21T18:35:25Z",
          "updatedAt": "2025-04-21T18:35:25Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "If we're going to use the term \"blocklist\", we either need to define it or add a reference for it, as it's not a commonly understood term.  I would suggest rewording to not use the term, as that may result in text that's easier to read.",
              "createdAt": "2025-04-21T18:35:25Z",
              "updatedAt": "2025-04-21T18:35:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6l0Z_v",
          "commit": {
            "abbreviatedOid": "b7a8513"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-21T18:36:57Z",
          "updatedAt": "2025-04-21T18:36:58Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "The term \"Security Policy\" will mean different things than intended to some readers.\r\n\r\nMaybe change the title to something more like \"Algorithm Verification Code Not Defensively Written\".",
              "createdAt": "2025-04-21T18:36:58Z",
              "updatedAt": "2025-04-21T18:36:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6pxgyB",
          "commit": {
            "abbreviatedOid": "009db6d"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-05-17T15:30:36Z",
          "updatedAt": "2025-05-17T15:30:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 8,
      "id": "PR_kwDONgvdIs6TcKyL",
      "title": "Encryption/signature confusion",
      "url": "https://github.com/yaronf/draft-sheffer-oauth-rfc8725bis/pull/8",
      "state": "OPEN",
      "author": "yaronf",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Closes #4.",
      "createdAt": "2025-04-22T13:27:00Z",
      "updatedAt": "2025-05-22T00:49:28Z",
      "baseRepository": "yaronf/draft-sheffer-oauth-rfc8725bis",
      "baseRefName": "main",
      "baseRefOid": "a77673ae22b8366274c42e04a44145217725f1ec",
      "headRepository": "yaronf/draft-sheffer-oauth-rfc8725bis",
      "headRefName": "ys-4",
      "headRefOid": "782fb0216394dea6940db75001caed8f90c409c1",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "> if you're accepting a JWE, you also need a private key in the JWK to decrypt the thing. So the attack (sending a JWE instead of a JWS) only works if there's a private key on the receiver's side.\r\n\r\nIt's true that the recipient needs a private key to decrypt the encrypted JWT.  But it's not true that the private key needs to be in the JWK.  Typically only the public keys would be in the JWK.  The private key would normally be privately held by the recipient - not published in a JWK.",
          "createdAt": "2025-05-17T15:47:44Z",
          "updatedAt": "2025-05-17T15:47:44Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "OWNER",
          "body": "> > if you're accepting a JWE, you also need a private key in the JWK to decrypt the thing. So the attack (sending a JWE instead of a JWS) only works if there's a private key on the receiver's side.\r\n> \r\n> It's true that the recipient needs a private key to decrypt the encrypted JWT. But it's not true that the private key needs to be in the JWK. Typically only the public keys would be in the JWK. The private key would normally be privately held by the recipient - not published in a JWK.\r\n\r\nFirst, I'm quoting the researcher who reported the issue in #4. For more detail see slides 17-19 [here](https://i.blackhat.com/BH-US-23/Presentations/US-23-Tervoort-Three-New-Attacks-Against-JSON-Web-Tokens.pdf).\r\n\r\nAlso, the point is not that the private key is published along with the JWK, but that when the JWK is used locally in the receiver's call to the JOSE library, in includes the private key.",
          "createdAt": "2025-05-17T21:58:24Z",
          "updatedAt": "2025-05-17T21:58:24Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "Please add a history entry for this change.",
          "createdAt": "2025-05-21T22:43:23Z",
          "updatedAt": "2025-05-21T22:43:23Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "> Also, the point is not that the private key is published along with the JWK, but that when the JWK is used locally in the receiver's call to the JOSE library, in includes the private key.\r\n\r\nJWK is a format for a key. Libraries also take PEM format for the key as well -> 'JWK' is not a correct way to refer to the key -- not that it matters for this PR ",
          "createdAt": "2025-05-22T00:18:50Z",
          "updatedAt": "2025-05-22T00:49:27Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDONgvdIs6o3laS",
          "commit": {
            "abbreviatedOid": "0389dda"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-12T13:02:42Z",
          "updatedAt": "2025-05-12T13:02:43Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "```suggestion\r\nLibraries MUST allow the verifier to distinguish between JWS-signed and JWE-encrypted JWTs, enabling callers to accept only JWTs that meet their security criteria.\r\n```",
              "createdAt": "2025-05-12T13:02:42Z",
              "updatedAt": "2025-05-12T13:02:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6o40RM",
          "commit": {
            "abbreviatedOid": "0389dda"
          },
          "author": "yaronf",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-12T14:32:01Z",
          "updatedAt": "2025-05-12T14:32:01Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "That would allow the verifier to only accept JWS, if that's their policy.",
              "createdAt": "2025-05-12T14:32:01Z",
              "updatedAt": "2025-05-12T14:32:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6o42ec",
          "commit": {
            "abbreviatedOid": "0389dda"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-12T14:34:50Z",
          "updatedAt": "2025-05-12T14:34:50Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "```suggestion\r\n```\r\n\r\nThis is unrelated to the other changes in this PR.  Please remove it.\r\n\r\nThis also contradicts https://www.rfc-editor.org/rfc/rfc7519.html#section-11.2.",
              "createdAt": "2025-05-12T14:34:50Z",
              "updatedAt": "2025-05-12T14:42:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6o45j-",
          "commit": {
            "abbreviatedOid": "0389dda"
          },
          "author": "yaronf",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-12T14:38:49Z",
          "updatedAt": "2025-05-12T14:38:50Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "Move into a separate PR.\r\n\r\nThis would contradict https://www.rfc-editor.org/rfc/rfc7519.html#section-11.2",
              "createdAt": "2025-05-12T14:38:50Z",
              "updatedAt": "2025-05-12T14:41:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6pxabG",
          "commit": {
            "abbreviatedOid": "0389dda"
          },
          "author": "yaronf",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-17T14:48:27Z",
          "updatedAt": "2025-05-17T14:48:27Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "For the record, the following in RFC 7519 convinced me:\r\n\r\n> Note that potential concerns about security issues related to the order of signing and encryption operations are already addressed by the underlying JWS and JWE specifications; in particular, because JWE **only supports the use of authenticated encryption algorithms**, cryptographic concerns about the potential need to sign after encryption that apply in many contexts do not apply to this specification.",
              "createdAt": "2025-05-17T14:48:27Z",
              "updatedAt": "2025-05-17T14:48:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6pxf-K",
          "commit": {
            "abbreviatedOid": "bd1f190"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-17T15:27:28Z",
          "updatedAt": "2025-05-17T15:27:28Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "I don't understand what the phrase \"when the verifier's asymmetric key includes the private key\" is getting at.  How does this relate to the vulnerability?",
              "createdAt": "2025-05-17T15:27:28Z",
              "updatedAt": "2025-05-17T15:27:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6pxgJB",
          "commit": {
            "abbreviatedOid": "bd1f190"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-17T15:28:01Z",
          "updatedAt": "2025-05-17T15:28:02Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "```suggestion\r\nIn the more complicated use cases where confidentiality is required, some libraries that decrypt a JWE-encrypted JWT to obtain a JWS-signed object\r\n```",
              "createdAt": "2025-05-17T15:28:02Z",
              "updatedAt": "2025-05-17T15:28:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6pxiMv",
          "commit": {
            "abbreviatedOid": "bd1f190"
          },
          "author": "yaronf",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-17T15:41:01Z",
          "updatedAt": "2025-05-17T15:41:02Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "On the receiver side, if all you want is a JWS then you only need a public key in the JWK, to verify the signature.\r\n\r\nBut if you're accepting a JWE, you also need a private key in the JWK to decrypt the thing. So the attack (sending a JWE instead of a JWS) only works if there's a private key on the receiver's side.",
              "createdAt": "2025-05-17T15:41:01Z",
              "updatedAt": "2025-05-17T15:41:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6px1mf",
          "commit": {
            "abbreviatedOid": "782fb02"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-17T22:14:01Z",
          "updatedAt": "2025-05-17T22:14:02Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\nMost authentication use cases only require a simple signed JWT as their token. However verifiers don't always check that the received JWT is a signed JWS as opposed to an encrypted JWE structure. This can result in vulnerabilities when the verifier's library does not distinguish between successful decryption and successful signature validation {{CVE-2023-51774}}.\r\n```\r\n\r\nDelete the ambiguous phrase",
              "createdAt": "2025-05-17T22:14:01Z",
              "updatedAt": "2025-05-17T22:14:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qbPDv",
          "commit": {
            "abbreviatedOid": "782fb02"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-21T22:22:56Z",
          "updatedAt": "2025-05-21T22:22:56Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Please apply my suggestion deleting the ambiguous phrase, then I will approve.",
              "createdAt": "2025-05-21T22:22:56Z",
              "updatedAt": "2025-05-21T22:22:56Z"
            }
          ]
        }
      ]
    },
    {
      "number": 9,
      "id": "PR_kwDONgvdIs6V1wo7",
      "title": "Reject unreasonably large \"p2c\" values",
      "url": "https://github.com/yaronf/draft-sheffer-oauth-rfc8725bis/pull/9",
      "state": "MERGED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #1 ",
      "createdAt": "2025-05-12T13:33:45Z",
      "updatedAt": "2025-05-18T01:14:45Z",
      "baseRepository": "yaronf/draft-sheffer-oauth-rfc8725bis",
      "baseRefName": "main",
      "baseRefOid": "7e104a7798e8d375382967df02ca275e328dbebf",
      "headRepository": "yaronf/draft-sheffer-oauth-rfc8725bis",
      "headRefName": "mbj-p2c",
      "headRefOid": "fc8840a620791bf1486466bd334a7ee512ffd52c",
      "closedAt": "2025-05-18T01:14:45Z",
      "mergedAt": "2025-05-18T01:14:45Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "e624354927ac64871ba37a948891449791daf824"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONgvdIs6o5Cip",
          "commit": {
            "abbreviatedOid": "2a37ab4"
          },
          "author": "yaronf",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-12T14:47:37Z",
          "updatedAt": "2025-05-12T14:47:37Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "1M?\r\n\r\nhttps://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html",
              "createdAt": "2025-05-12T14:47:37Z",
              "updatedAt": "2025-05-12T14:47:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6pxR4T",
          "commit": {
            "abbreviatedOid": "af7a71e"
          },
          "author": "yaronf",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-05-17T12:29:19Z",
          "updatedAt": "2025-05-17T12:29:19Z",
          "comments": []
        },
        {
          "id": "PRR_kwDONgvdIs6pxrfq",
          "commit": {
            "abbreviatedOid": "2a37ab4"
          },
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-17T18:46:12Z",
          "updatedAt": "2025-05-17T18:46:12Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "I thought 1M was what was recommended as well -- is 10,000 too low?",
              "createdAt": "2025-05-17T18:46:12Z",
              "updatedAt": "2025-05-17T18:46:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6pxrlt",
          "commit": {
            "abbreviatedOid": "2a37ab4"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-17T18:48:14Z",
          "updatedAt": "2025-05-17T18:48:14Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "You're looking at outdated text.  Look at the files changed.  It's now 1.2M - double the NIST value.",
              "createdAt": "2025-05-17T18:48:14Z",
              "updatedAt": "2025-05-17T18:48:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6pyDNd",
          "commit": {
            "abbreviatedOid": "af7a71e"
          },
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-05-18T00:08:08Z",
          "updatedAt": "2025-05-18T00:08:23Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "I am looking at the files changed -- at least I think I am! If 1.2M then I'm fine. ",
              "createdAt": "2025-05-18T00:08:09Z",
              "updatedAt": "2025-05-18T00:08:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 10,
      "id": "PR_kwDONgvdIs6W-pJd",
      "title": "Mitigation for Compression DoS #3",
      "url": "https://github.com/yaronf/draft-sheffer-oauth-rfc8725bis/pull/10",
      "state": "MERGED",
      "author": "dickhardt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "yaronf",
        "selfissued"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2025-05-21T02:04:15Z",
      "updatedAt": "2025-05-21T22:24:26Z",
      "baseRepository": "yaronf/draft-sheffer-oauth-rfc8725bis",
      "baseRefName": "main",
      "baseRefOid": "e624354927ac64871ba37a948891449791daf824",
      "headRepository": "yaronf/draft-sheffer-oauth-rfc8725bis",
      "headRefName": "Mitigation-for-Compression-DoS-#3",
      "headRefOid": "4f5f1478a28ecc2278d1f0f563bf649d7e3b0b5a",
      "closedAt": "2025-05-21T22:24:26Z",
      "mergedAt": "2025-05-21T22:24:26Z",
      "mergedBy": "dickhardt",
      "mergeCommit": {
        "oid": "6ed92926d8726fa357eb1d62aba88e1945520d73"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONgvdIs6qTP7J",
          "commit": {
            "abbreviatedOid": "79e83f0"
          },
          "author": "yaronf",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-21T10:28:55Z",
          "updatedAt": "2025-05-21T10:28:55Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Wrong RFC number, didn't check the section number.",
              "createdAt": "2025-05-21T10:28:55Z",
              "updatedAt": "2025-05-21T10:28:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qaxRi",
          "commit": {
            "abbreviatedOid": "4f5f147"
          },
          "author": "yaronf",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-05-21T21:15:21Z",
          "updatedAt": "2025-05-21T21:15:21Z",
          "comments": []
        },
        {
          "id": "PRR_kwDONgvdIs6qbNBL",
          "commit": {
            "abbreviatedOid": "4f5f147"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-05-21T22:16:15Z",
          "updatedAt": "2025-05-21T22:16:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 11,
      "id": "PR_kwDONgvdIs6W-xZP",
      "title": "Mitigation for JWT Format Confusion #2",
      "url": "https://github.com/yaronf/draft-sheffer-oauth-rfc8725bis/pull/11",
      "state": "OPEN",
      "author": "dickhardt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "yaronf",
        "selfissued"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2025-05-21T02:29:15Z",
      "updatedAt": "2025-05-22T00:14:28Z",
      "baseRepository": "yaronf/draft-sheffer-oauth-rfc8725bis",
      "baseRefName": "main",
      "baseRefOid": "6ed92926d8726fa357eb1d62aba88e1945520d73",
      "headRepository": "yaronf/draft-sheffer-oauth-rfc8725bis",
      "headRefName": "Mitigation-for-JWT-Format-Confusion-#2",
      "headRefOid": "b66067420a6291a03f421debb09924fdeeab4f99",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "@yaronf does Mike's suggestion (which I accepted resolve your concern?",
          "createdAt": "2025-05-21T22:29:11Z",
          "updatedAt": "2025-05-21T22:29:11Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "Please add a history entry for this change.",
          "createdAt": "2025-05-21T22:42:50Z",
          "updatedAt": "2025-05-21T22:42:50Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDONgvdIs6qUfAP",
          "commit": {
            "abbreviatedOid": "b384f7d"
          },
          "author": "yaronf",
          "authorAssociation": "OWNER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2025-05-21T12:20:02Z",
          "updatedAt": "2025-05-21T14:39:58Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I think we should mention that JSON Serialization is not compliant with the RFC. (To be clear, we should still mention it because it happens in reality).",
              "createdAt": "2025-05-21T12:20:02Z",
              "updatedAt": "2025-05-21T14:39:58Z"
            },
            {
              "originalPosition": 20,
              "body": "RECOMMENDED means SHOULD. Why not make it a MUST?",
              "createdAt": "2025-05-21T14:39:04Z",
              "updatedAt": "2025-05-21T14:39:58Z"
            },
            {
              "originalPosition": 20,
              "body": "```suggestion\r\nImplementations are RECOMMENDED to confirm if the JWT is a supported format before parsing the JWT. If the implementation only supports the compact format, the token will start with 'e' (ASCII 0x65) and if the implementation supports the JSON format, the token will start with '{' (ASCII 0x7B). \r\n```",
              "createdAt": "2025-05-21T14:39:45Z",
              "updatedAt": "2025-05-21T14:39:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qZbg4",
          "commit": {
            "abbreviatedOid": "b384f7d"
          },
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-21T18:47:09Z",
          "updatedAt": "2025-05-21T18:47:09Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I thought JSON serialization was a valid format. No?",
              "createdAt": "2025-05-21T18:47:09Z",
              "updatedAt": "2025-05-21T18:47:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qayQB",
          "commit": {
            "abbreviatedOid": "c2a21e8"
          },
          "author": "yaronf",
          "authorAssociation": "OWNER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2025-05-21T21:17:28Z",
          "updatedAt": "2025-05-21T21:20:32Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "```suggestion\r\nImplementations MUST confirm that the JWT is a supported format before parsing the JWT. If the implementation only supports the compact format, the token will start with 'e' (ASCII 0x65) and if the implementation supports the JSON format, the token will start with '{' (ASCII 0x7B).\r\n```",
              "createdAt": "2025-05-21T21:17:28Z",
              "updatedAt": "2025-05-21T21:20:32Z"
            },
            {
              "originalPosition": 6,
              "body": "Quoting RFC 7519: \"JWTs are always represented using the JWS Compact Serialization or the JWE Compact Serialization.\"",
              "createdAt": "2025-05-21T21:20:23Z",
              "updatedAt": "2025-05-21T21:20:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qbPiM",
          "commit": {
            "abbreviatedOid": "b384f7d"
          },
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-21T22:24:05Z",
          "updatedAt": "2025-05-21T22:24:06Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "While 7519 defines a JWT and that it is the compact serialization, 7515 (JWS) and 7516 (JWE) both define a compact and JSON serialization, and the attack was a library that would take both of those serializations, which sortof makes sense as they are both defined in 7515 and 7516.\r\n\r\nhttps://datatracker.ietf.org/doc/html/rfc7515#section-7\r\n\r\nhttps://datatracker.ietf.org/doc/html/rfc7516#section-7\r\n\r\n@selfissued what are your thoughts?\r\n\r\n",
              "createdAt": "2025-05-21T22:24:05Z",
              "updatedAt": "2025-05-21T22:24:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qbQ3R",
          "commit": {
            "abbreviatedOid": "c2a21e8"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-21T22:26:51Z",
          "updatedAt": "2025-05-21T22:26:52Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nSome JWS implementations support both the Compact and JSON Serializations. While JWTs MUST use the Compact Serialization, if an application by mistake verifies a JWT using the JSON Serialization but extracts claims by parsing it as a JWT using the Compact Serialization (e.g., via string splitting), an attacker can craft a valid JSON JWS with a forged payload. This mismatch in format handling can lead to authentication bypass or impersonation.\r\n```",
              "createdAt": "2025-05-21T22:26:52Z",
              "updatedAt": "2025-05-21T22:26:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qbaX1",
          "commit": {
            "abbreviatedOid": "c2a21e8"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-21T22:39:44Z",
          "updatedAt": "2025-05-21T22:39:44Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "```suggestion\r\nImplementations MUST confirm the JWT is in a legal format while parsing it. Legal JWTs contain only the ASCII characters for letters, numbers, dash, underscore, and period.  Content with any other characters - especially braces and quotation marks - is not a JWT and MUST be rejected.\r\n```\r\n\r\nJWTs don't have to start with an \"e\" if there is leading space in the JSON before base64url-encoding.  Similarly, content using the JWS JSON Serialization doesn't have to start with \"{\" because it can have leading spaces.",
              "createdAt": "2025-05-21T22:39:44Z",
              "updatedAt": "2025-05-21T22:41:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qbdP4",
          "commit": {
            "abbreviatedOid": "b385151"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-21T22:46:32Z",
          "updatedAt": "2025-05-21T22:46:32Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "```suggestion\r\nImplementations MUST confirm the JWT is in a legal format while parsing it. Legal JWTs contain only the ASCII characters for letters, numbers, dash, underscore, and period.  Content with any other characters - especially braces and quotation marks - is not a JWT and MUST be rejected.\r\n```\r\n\r\nBecause of leading spaces being legal in JSON, neither of the \"e\" nor \"{\" statements is true.",
              "createdAt": "2025-05-21T22:46:32Z",
              "updatedAt": "2025-05-21T22:46:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qbdeQ",
          "commit": {
            "abbreviatedOid": "b384f7d"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-21T22:47:26Z",
          "updatedAt": "2025-05-21T22:47:26Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "My thoughts are in my change suggestion about JWTs containing only letters, numbers, dash, underscore, and period.",
              "createdAt": "2025-05-21T22:47:26Z",
              "updatedAt": "2025-05-21T22:47:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qb3Xk",
          "commit": {
            "abbreviatedOid": "c2a21e8"
          },
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T00:14:28Z",
          "updatedAt": "2025-05-22T00:14:28Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "That is a better check, thanks Mike.",
              "createdAt": "2025-05-22T00:14:28Z",
              "updatedAt": "2025-05-22T00:14:28Z"
            }
          ]
        }
      ]
    }
  ]
}