{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2026-01-13T00:07:21.242687+00:00",
  "repo": "oauth-wg/draft-ietf-oauth-rfc8725bis",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDONgvdIs6lD8EI",
      "title": "Mitigation for Billion Hashes Attack",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/issues/1",
      "state": "CLOSED",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "selfissued"
      ],
      "labels": [],
      "body": "From Jesse Yang <p3ngu1nw@gmail.com>\r\n\r\nDuring our testing, nine libraries were vulnerable to the Billion Hashes Attack. The root cause of this issue is that there is no limit on the size of the p2c claim in the JWE encrypted by the PBES2 algorithm, which causes the server to run billions of hash calculations when decrypting the JWE, causing a denial of service attack. Therefore, we propose adding a warning about this threat in RFC8725 and recommending an upper limit on the size of the p2c claim to mitigate the risk.\r\n",
      "createdAt": "2025-01-05T13:22:41Z",
      "updatedAt": "2025-05-18T01:14:46Z",
      "closedAt": "2025-05-18T01:14:46Z",
      "comments": [
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "See also https://i.blackhat.com/BH-US-23/Presentations/US-23-Tervoort-Three-New-Attacks-Against-JSON-Web-Tokens.pdf",
          "createdAt": "2025-01-05T14:07:42Z",
          "updatedAt": "2025-01-05T14:07:42Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @P3ngu1nW\n",
          "createdAt": "2025-01-16T16:18:31Z",
          "updatedAt": "2025-01-16T16:18:31Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "I_kwDONgvdIs6lD8N6",
      "title": "Mitigation for JWT Format Confusion",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/issues/2",
      "state": "CLOSED",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "dickhardt"
      ],
      "labels": [],
      "body": "From Jesse Yang <p3ngu1nw@gmail.com>\r\n\r\nWe found four libraries that support JSON-type JWS when parsing JWT. If the user extracts the payload by string interception after verification, the attacker can forge the content, which leads to JWT Format Confusion. We found such an exploitation case in Openshift Telemeter (CVE-2024-5037[1]) and Kubernetes identity verification[2] that supports parsing JSON JWS and leading to authentication bypass. Therefore, we propose to include this threat in RFC8725 for systematic consideration and advise against parsing JSON JWSs.\r\n\r\n[1]: https://nvd.nist.gov/vuln/detail/cve-2024-5037\r\n[2]: https://github.com/kubernetes/kubernetes/pull/123540",
      "createdAt": "2025-01-05T13:24:15Z",
      "updatedAt": "2025-05-23T09:23:04Z",
      "closedAt": "2025-05-23T09:23:03Z",
      "comments": [
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "See also https://bugzilla.redhat.com/show_bug.cgi?id=2272339\r\n\r\nAnd \"polyglot JWS\" here: https://i.blackhat.com/BH-US-23/Presentations/US-23-Tervoort-Three-New-Attacks-Against-JSON-Web-Tokens.pdf",
          "createdAt": "2025-01-05T13:59:54Z",
          "updatedAt": "2025-01-05T13:59:54Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @P3ngu1nW\n",
          "createdAt": "2025-01-16T16:18:20Z",
          "updatedAt": "2025-01-16T16:18:20Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "https://www.rfc-editor.org/rfc/rfc7519.html#section-1 says:\n> JWTs are always   represented using the JWS Compact Serialization or the JWE Compact   Serialization.\n\nJWT parsers need to enforce this.",
          "createdAt": "2025-05-12T14:51:57Z",
          "updatedAt": "2025-05-12T14:51:57Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #11 .",
          "createdAt": "2025-05-23T09:23:03Z",
          "updatedAt": "2025-05-23T09:23:03Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDONgvdIs6lD8aL",
      "title": "Mitigation for Compression DoS",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/issues/3",
      "state": "CLOSED",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "dickhardt"
      ],
      "labels": [],
      "body": "From Jesse Yang <p3ngu1nw@gmail.com>\r\n\r\nJWE allows the payload to be compressed and then decompressed after the recipient decrypts the JWE. However, we observed that 13 libraries did not check the length of the JWE when decompressing it. This means that an attacker can encrypt a very long and malicious JWT and send it to the recipient, causing a denial of service attack. Therefore, we suggest adding this issue in RFC8725 and recommending a upper limit on the length of JWE.",
      "createdAt": "2025-01-05T13:26:15Z",
      "updatedAt": "2025-05-21T22:24:45Z",
      "closedAt": "2025-05-21T22:24:45Z",
      "comments": [
        {
          "author": "panva",
          "authorAssociation": "MEMBER",
          "body": "@P3ngu1nW and I did go through a [fix on my library a year ago](https://github.com/panva/jose/security/advisories/GHSA-hhhv-q57g-882q), https://github.com/panva/jose/commit/1b91d88d2f8233f3477a5f4579aa5f8057b2ee8b\n\nI don't believe checking for token length is the right solution, it's very crude and error prone. Instead, and that's what I've implemented, when working with compressed content it's important to set decompression output length limits. Routines responsible for decompresssion usually have such settings.\n\nThis way you're dealing with the high compression ratio part without introducing arbitrary token length limits.",
          "createdAt": "2025-01-16T15:58:47Z",
          "updatedAt": "2025-05-13T08:47:07Z"
        },
        {
          "author": "panva",
          "authorAssociation": "MEMBER",
          "body": "FWIW @b---c opted in for the same kind of mitigation in jose4j",
          "createdAt": "2025-01-16T18:59:33Z",
          "updatedAt": "2025-01-16T18:59:33Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "NONE",
          "body": "Thanks for the better memory than me, @panva. But I agree with your assessment (as I often do).  Here is the fix in my library https://bitbucket.org/b_c/jose4j/commits/19a90a64c47b - looks like I was a day before Filip with the fix :) ",
          "createdAt": "2025-01-16T20:50:31Z",
          "updatedAt": "2025-01-16T20:50:31Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "notes for @dickhardt \n\n- set a max size for decompression - 250 MB is commonly used??",
          "createdAt": "2025-05-12T14:57:10Z",
          "updatedAt": "2025-05-12T14:57:10Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "NONE",
          "body": "> notes for [@dickhardt](https://github.com/dickhardt)\n> \n>    * set a max size for decompression - 250 MB is commonly used??\n\nno, I think the commonly used limits are over one thousand times smaller than that ",
          "createdAt": "2025-05-12T15:26:47Z",
          "updatedAt": "2025-05-12T15:26:57Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "> > notes for [@dickhardt](https://github.com/dickhardt)\n> > \n> > * set a max size for decompression - 250 MB is commonly used??\n> \n> no, I think the commonly used limits are over one thousand times smaller than that\n\ndoh! -- meant KB ",
          "createdAt": "2025-05-21T01:34:19Z",
          "updatedAt": "2025-05-21T01:34:19Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDONgvdIs6lD8gR",
      "title": "Mitigation for JWS/JWE Confusion",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/issues/4",
      "state": "CLOSED",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "yaronf"
      ],
      "labels": [],
      "body": "From Jesse Yang <p3ngu1nw@gmail.com>\r\n\r\nJWT allows users to pass in JWS and JWE when parsing, but mixing these two tokens will cause security issues. During our testing, we found two libraries are vulnerable to this issue where attackers use public key encrypted JWE to bypass the parsing of JWT using asymmetric encryption algorithms. The root cause of this security issue is that the JWK implemented allows both public and private keys to be included, resulting in a bypass even if the algorithm is verified according to the method mentioned in RFC8725 3.1 (check whether the RSA algorithm is used). Therefore, we propose adding a warning about this threat in RFC8725 and advising developers not to include both public and private keys in JWK, and check the \"use\" claim in JWK before parsing JWT.",
      "createdAt": "2025-01-05T13:27:14Z",
      "updatedAt": "2025-05-23T09:21:56Z",
      "closedAt": "2025-05-23T09:21:56Z",
      "comments": [
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "See also \"sign/encrypt confusion\" here: https://i.blackhat.com/BH-US-23/Presentations/US-23-Tervoort-Three-New-Attacks-Against-JSON-Web-Tokens.pdf",
          "createdAt": "2025-01-05T14:01:17Z",
          "updatedAt": "2025-01-05T14:01:17Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @P3ngu1nW\n",
          "createdAt": "2025-01-16T16:17:59Z",
          "updatedAt": "2025-01-16T16:17:59Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm fine warning people not to publish their private keys.",
          "createdAt": "2025-04-21T14:25:35Z",
          "updatedAt": "2025-04-21T14:25:35Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm fine warning people that if they require a signature on a JWT, that they must verify that the content was signed.",
          "createdAt": "2025-04-21T14:42:10Z",
          "updatedAt": "2025-04-21T14:42:10Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": " @P3ngu1nW Do you have any references or CVEs for this vulnerability?",
          "createdAt": "2025-04-22T08:00:56Z",
          "updatedAt": "2025-04-22T08:00:56Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "https://www.cve.org/CVERecord?id=CVE-2023-51774",
          "createdAt": "2025-04-22T13:11:38Z",
          "updatedAt": "2025-04-22T13:11:38Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDONgvdIs6lD-l3",
      "title": "Key Identification guidance",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/issues/5",
      "state": "CLOSED",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "selfissued"
      ],
      "labels": [],
      "body": "Now that we're reopening the JWT BCP, should we include the guidance on key identification from Hannes' draft, https://datatracker.ietf.org/doc/draft-tschofenig-jose-cose-guidance/ ?\r\n\r\nThe target audience for the drafts may be different though, with the JWT BCP targeting library authors and the \"guidance\" draft aimed at application writers.",
      "createdAt": "2025-01-05T13:48:38Z",
      "updatedAt": "2025-11-17T17:50:22Z",
      "closedAt": "2025-11-17T17:50:22Z",
      "comments": [
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "It would be fine to describe how the `kid` header parameter should be used to perform key identification.\r\n\r\n@hannestschofenig warns against key identification information in the payload of a JWT but doesn't give any examples of when and why this is done.  I'd like to understand the nature of the problem before talking about solutions.\r\n\r\nThat said, it's normal to use claims from the payload - in particular, the `iss` claim - in the procedure to retrieve the keys.  For instance, [Obtaining OpenID Provider Configuration Information](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig) requires appending `.well-known/openid-configuration` to the `iss` claim value in an ID Token as part of the process of retrieving the signing keys.  This is a feature - not a bug - as it guarantees that the keys belong to the issuer.\r\n\r\nOur target audience should be all kinds of developers - both library and application developers.",
          "createdAt": "2025-01-05T19:53:37Z",
          "updatedAt": "2025-01-05T19:53:37Z"
        },
        {
          "author": "hannestschofenig",
          "authorAssociation": "NONE",
          "body": "The point of the draft was the following:\n\nYou need to give the recipient some means to identify the key it has to use for verification. This is information that needs to be either explit in the JWT (or in a COSE structure in general) or implicit (typically through some other layer outside).\n\nOnce you have this information you do not need other information anymore, such as algorithm identifiers, since the recipient needs to also know (in addition to the key identifier) what algorithm to use. If the recipient does not already possess this information then there is a risk that an attacker modifies information, such as the algorithm.",
          "createdAt": "2025-04-21T16:49:53Z",
          "updatedAt": "2025-04-21T16:49:53Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "@hannestschofenig, I'm still not sure what attack you're describing or how it should be mitigated.\n\nFor instance, when the \"alg\" value is a protected header parameter, the attacker can't modify it.  This is true both for signed JWTs and encrypted JWTs using an AEAD algorithm.  The only case where it's not true is \"alg\": \"none\", which RFC 8725 already discusses.",
          "createdAt": "2025-05-12T13:54:06Z",
          "updatedAt": "2025-05-12T13:54:06Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "> That said, it's normal to use claims from the payload - in particular, the `iss` claim - in the procedure to retrieve the keys. For instance, [Obtaining OpenID Provider Configuration Information](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig) requires appending `.well-known/openid-configuration` to the `iss` claim value in an ID Token as part of the process of retrieving the signing keys. This is a feature - not a bug - as it guarantees that the keys belong to the issuer.\n\nI disagree. IMHO this is a bug: the original JOSE architecture only requires the recipient to parse the smaller/simpler header in order to validate the whole JWS.\n\nThe OIDC solution means the recipient should go through hoops instead:\n* Parse an **untrusted** JWS (which may try to exploit JSON parsing vulnerabilities) to obtain `iss`.\n* Use that value to access an **untrusted** URL to read a public key.\n* Verify the JWS.\n* If this fails, make sure to throw away the already parsed JWS, whose claims may already be cached somewhere.\n\n[CVE-2025-30144](https://nvd.nist.gov/vuln/detail/CVE-2025-30144) is a related vulnerability.\n",
          "createdAt": "2025-05-17T14:36:59Z",
          "updatedAt": "2025-05-17T14:36:59Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "> the original JOSE architecture only requires the recipient to parse the smaller/simpler header in order to validate the whole JWS.\n\nThat's not a complete description of the situation.  JWS does not define a way to know the keys or validate control of them.  Nor does JWT.  OpenID Connect ID Tokens do, for example.\n\nJWT does define claims used to validate control of the keys - especially \"iss\".  That's not a bug - it's a super-useful and widely used feature.\n\n> Parse an untrusted JWS (which may try to exploit JSON parsing vulnerabilities) to obtain iss.\n\nAll JWTs are untrusted until their integrity and issuer have been validated.  Nothing new.\n\nIf you can't parse bytes that purport to be JSON without exercising JSON parsing vulnerabilities in your code, you have bigger problems than those related to JWTs.\n\n> Use that value to access an untrusted URL to read a public key.\n\nThat the URL trustworthy is confirmed by validating the signature using a key obtained.  If the signature doesn't validate using a key obtained by the issuer, the JWT is rejected, along with any content retrieved from the URL.\n\n> If this fails, make sure to throw away the already parsed JWS, whose claims may already be cached somewhere.\n\nIf you cache claims from a rejected JWT, that's simply a code bug.",
          "createdAt": "2025-05-17T15:40:04Z",
          "updatedAt": "2025-05-17T15:40:04Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "To address this issue, we need to identify the attacks we will describe in the text and how we're mitigating them.  @hannestschofenig?\n\nUnless we identify attacks and mitigations, we should close this issue with no action.",
          "createdAt": "2025-05-21T22:52:14Z",
          "updatedAt": "2025-05-21T22:52:14Z"
        },
        {
          "author": "hannestschofenig",
          "authorAssociation": "NONE",
          "body": "Since you do not believe me, maybe you believe Sophie: https://mailarchive.ietf.org/arch/msg/cose/Vj2Wy9hM_Sc0osegJjEvp6N-kvg/",
          "createdAt": "2025-11-05T15:04:07Z",
          "updatedAt": "2025-11-05T15:04:07Z"
        },
        {
          "author": "hannestschofenig",
          "authorAssociation": "NONE",
          "body": "There are two types of attacks:\n\n1. Downgrading attacks like the LAMPS attack where an attacker modifies a AEAD cipher and downgrades it to some other cipher like a non-AEAD cipher.\n\n2. Attacker causes the victim to incorrectly apply the key to an algorithm that was not intended by the victim.\n\nAs a general guideline: See Section 5.2 of  NIST SP 800-57 Part 1 Rev. 5: \"In general, a single key shall be used for only one purpose...\"",
          "createdAt": "2025-11-05T16:18:33Z",
          "updatedAt": "2025-11-05T16:18:33Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we are talking past one another. Sophie's text is about both `kid` and `alg`. Both the attacks @hannestschofenig mentions are related to `alg`. @selfissued discussion above is mostly about `kid`.\n\nI would support something like:\n\n* Applications SHOULD not include an `alg` header in the JWT. It is RECOMMENDED that verifiers ignore an `alg` header if it exists, and only use the cryptographic key to determine the signature algorithm.\n\nRe: `kid` I actually read Sophie's text differently. I agree there are practical risks in having the key ID in the signed token vs. the header, but I think her point is that from a pure security point of view, both are the same. `kid` is inherently risky. So I don't think we should add text related to `kid`.",
          "createdAt": "2025-11-08T21:05:42Z",
          "updatedAt": "2025-11-08T21:05:42Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "\"alg\" is a required header parameter with defined processing rules. It would be a totally unnecessary breaking change to deviate from that.",
          "createdAt": "2025-11-10T00:35:32Z",
          "updatedAt": "2025-11-10T00:35:32Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "> \"alg\" is a required header parameter with defined processing rules. It would be a totally unnecessary breaking change to deviate from that.\n\nTo your point on \"defined processing rules\", Sec. 3.1 of the RFC adds a bunch of rules that weren't there before the BCP. Here's hoping that people actually implemented them.\n\nI wish the OAuth WG/community was open to deprecating elements, such as `alg`, that actively hurt security. But a BCP is not the right place to do it anyway. Maybe we should write a \"deprecating 'alg'\" draft.",
          "createdAt": "2025-11-10T13:02:44Z",
          "updatedAt": "2025-11-10T13:02:44Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "> I wish the OAuth WG/community was open to deprecating elements, such as alg, that actively hurt security. But a BCP is not the right place to do it anyway. Maybe we should write a \"deprecating 'alg'\" draft.\n\nQuite to the contrary, \"alg\" helps security because it cryptographically binds the algorithm used into the signature computation.  Without that, any algorithm chosen by an attacker would be used.",
          "createdAt": "2025-11-10T15:23:29Z",
          "updatedAt": "2025-11-10T15:23:29Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "@selfissued Well, Sophie disagrees. See her text, specifically the paragraph that starts:\n\n> For the algorithm header field, I am not aware of any reason to have that in the token (other than the fact that it historically has been there).",
          "createdAt": "2025-11-11T11:22:38Z",
          "updatedAt": "2025-11-11T11:22:38Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "I replied to Sophie's point in the thread you cited @yaronf in the message https://mailarchive.ietf.org/arch/msg/cose/DRWVSo4R4BFD7JMvUiIJclmmSDw/.  My reply included the rationale for the decisions made 15 years ago with input from cryptographers and implementers that resulted in the JOSE and JWT specs that we have today.",
          "createdAt": "2025-11-11T20:58:36Z",
          "updatedAt": "2025-11-11T20:58:36Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed on today's editor's call, it is beyond the scope of the BCP to remove the requirement for the \"alg\" header parameter.",
          "createdAt": "2025-11-17T17:50:22Z",
          "updatedAt": "2025-11-17T17:50:22Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDONgvdIs6lEAKp",
      "title": "Case sensitivity of algorithm names",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/issues/6",
      "state": "CLOSED",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "yaronf"
      ],
      "labels": [],
      "body": "See slide 11 here: https://i.blackhat.com/BH-US-23/Presentations/US-23-Tervoort-Three-New-Attacks-Against-JSON-Web-Tokens.pdf",
      "createdAt": "2025-01-05T14:03:47Z",
      "updatedAt": "2025-05-17T15:35:50Z",
      "closedAt": "2025-05-17T15:35:50Z",
      "comments": [
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "Adding references - all related to Auth0.\n\n* https://stytch.com/blog/auth0-security-incidents/\n* https://cybercx.co.nz/blog/json-web-token-validation-bypass-in-auth0-authentication-api/\n\nBTW the Stytch blog gets the issue wrong: the problem is less about the case sensitive filtering and more about normalization of the \"alg\" field which is defined as case sensitive.\n\nAlso, this is an issue in proprietary, closed software. So full implementation details are not available.",
          "createdAt": "2025-05-17T15:21:50Z",
          "updatedAt": "2025-05-17T15:21:50Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "I_kwDONgvdIs637873",
      "title": "Acknowledgements",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/issues/13",
      "state": "CLOSED",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "selfissued"
      ],
      "labels": [],
      "body": "We need to acknowledge Jesse Yang @p3ngu1nw who effectively initiated the bis document.",
      "createdAt": "2025-05-23T10:34:08Z",
      "updatedAt": "2025-11-07T17:51:14Z",
      "closedAt": "2025-11-07T17:51:14Z",
      "comments": [
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "And maybe also Tom Tervoort who found several of these attacks.",
          "createdAt": "2025-05-23T10:36:51Z",
          "updatedAt": "2025-05-23T10:36:51Z"
        },
        {
          "author": "P3ngu1nW",
          "authorAssociation": "NONE",
          "body": "Thank you for your work on the updated JWT BCP, which further secures the JWT protocol.\nIf possible, we would be honored to be included in the acknowledgements section. In that case, please kindly list us as follows:\nJingcheng Yang(@P3ngu1nW), Mentor: Prof. Jianjun Chen(@chenjj), Collaborator: Enze Wang(@zer0yu)",
          "createdAt": "2025-05-24T02:16:06Z",
          "updatedAt": "2025-05-24T02:16:06Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "Add: Dan Moore and Aaron Parecki for extensive reviews.",
          "createdAt": "2025-07-14T20:23:19Z",
          "updatedAt": "2025-09-23T12:50:17Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "From @bc-pi:\n> Similarly it'd be good etiquette to, in the acknowledgements, distinguish between contributors to the original document and those that have contributed to the updates. I know from some github interactions, for one example, that \u2068Filip Skokan\u2069 has helped guide some of the updated text but he's not mentioned at present. \n\nSpecifically: https://github.com/yaronf/draft-sheffer-oauth-rfc8725bis/issues/3#issuecomment-2596104401",
          "createdAt": "2025-08-10T09:51:14Z",
          "updatedAt": "2025-08-10T11:12:20Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "I_kwDONgvdIs7AhT8r",
      "title": "Comments from Dan Moore",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/issues/14",
      "state": "CLOSED",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "yaronf"
      ],
      "labels": [],
      "body": "\n- [x] In https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#name-incorrect-use-and-compositi I'd change\n\"However verifiers don't always check that the received JWT is a signed JWS as opposed to an encrypted JWE structure.\"\nto \"However verifiers don't always check that the received JWT is a JWS (a signed JWT) as opposed to a JWE (a JWT with encrypted structure).\"\nA JWS is by definition signed, just as a JWE is by definition encrypted, so I thought this was clearer.\n\n- [x] In https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#section-2.4 I'd change\n\"Many encryption algorithms leak information about the length of the plaintext, with a varying amount of leakage depending on the algorithm and mode of operation.\"\nto \"Many encryption algorithms leak information about the length of the plaintext, with a varying amount of leakage depending on the algorithm and mode of operation. JWEs are vulnerable to this leakage.\"\nAlternatively you could add other language to make it clear this attack is applicable to JWEs, not JWTs in general, just as is done in https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#section-2.12 . I suppose you could even change the section header to \"JWE Plaintext Leakage through Analysis of Ciphertext Length\". In general there are a few security issues that are related to encryption and therefore only affect JWEs.\n\n- [x] In https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#section-2.5\nThe Sanso link is busted (expired cert, 404 for https://blogs.adobe.com/security/2017/03/critical-vulnerability-uncovered-in-json-encryption.html ) so you might want to review.\n\n- [x] Is the attack outlined here https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#section-2.5 the same as\nhttps://neilmadden.blog/2022/04/19/psychic-signatures-in-java/ ? If so, maybe that is a better link?\n\n- [x] In https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#section-2.8 I'd change\n\"As JWTs are being used by more different protocols in diverse application areas, it becomes increasingly important to prevent cases of JWT tokens that have been issued for one purpose being subverted and used for another.\"\nTo \"As JWTs are used by more protocols in diverse ways, it becomes increasingly important to prevent JWT tokens that have been issued for one purpose being used for another.\"\nJust think it reads cleaner.\n\n- [x] In https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#section-3.1-2 I'd change\n\"In particular, use allowlists for critical parameters such as \"alg\" instead of blocklists.\"\n\"In particular, libraries SHOULD use allowlists for critical parameters such as \"alg\" instead of blocklists.\"\nThis makes it a complete sentence.\n\n- [x] In https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#section-3.2 you quote the RFC which mentions SHOULD but then you follow it up with MUST. I find that confusing. I'd remove the first paragraph or at least this sentence: \"Even if a JWS can be successfully validated, unless the algorithm(s) used in the JWS are acceptable to the application, it SHOULD consider the JWS to be invalid.\" because then you remove the SHOULD/MUST confusion I had.\n\n- [x] In that same section, the semi-colon was awkward. I'd change\n\"JWTs using \"none\" are often used in application contexts in which the content is optionally signed; then, the URL-safe claims representation and processing can be the same in both the signed and unsigned cases.\"\nto\n\"JWTs using \"none\" are often used in application contexts in which the content is optionally signed. The URL-safe claims representation and processing in this context can be the same in both the signed and unsigned cases.\"\n\n- [x] In https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#section-3.3 I'd change\n\"Libraries MUST allow the verifier to distinguish between JWS-signed and JWE-encrypted JWTs. This would allow verifiers to easily establish a policy of only accepting JWS-signed JWTs.\"\nto\n\"Libraries MUST allow the verifier to distinguish between signed JWTs (JWSes) and encrypted JWTs (JWEs). This allows verifiers to easily establish a policy of only accepting signed JWTs.\"\nI found the terms JWS-signed and JWT-encrypted confusing. They felt internally redundant (a JWS is always signed, for example).\n\n- [x] In https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#section-3.6 I wondered if it made sense to mention JWEs here? Maybe change\n\"Compression of data SHOULD NOT be done before encryption, because such compressed data often reveals information about the plaintext.\"\nto \n\"Compression of data SHOULD NOT be used when creating a JWE, because such compressed data often reveals information about the plaintext.\"\nThis distinguishes between JWS and JWE, where the latter is the only one this recommendation applies to.\n\n- [x] In https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#section-3.7 I'd change\n\"Implementations and applications MUST do this and not use or admit the use of other Unicode encodings for these purposes.\"\nto\n\"Implementations and applications MUST do this and not use or allow the use of other Unicode encodings for these purposes.\"\nUnless \"admit\" means something special in this context, \"allow\" is clearer. \"allow\" seems more common and \"admit\" is not used elsewhere in this doc.\n\n- [x] In https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#section-3.9 I worry about changes to the implementation (where you start with one RP/app, then add more). I'd address this by adding a clause about the future:\n\"If the same issuer can issue JWTs that are intended for use by more than one relying party or application\"\nto\n\"If the same issuer can issue JWTs that are intended for use by more than one relying party or application, or may in the future,\"\n\n- [x] I'd also change\n\"or was substituted by an attacker at an unintended party.\"\nto\n\"or was substituted by an attacker.\"\nI'm not sure what the \"unintended party\" phrase adds.\n\n- [x] There's also this sentence:\n\"In such cases, the relying party or application MUST validate the audience value, and if the audience value is not present or not associated with the recipient, it MUST reject the JWT.\"\nThe aud claim can be an array https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.3 . Should we mention that here? Maybe something like:\n\"In such cases, the relying party or application MUST validate the audience value, and if no audience value is present or none of the values are associated with the recipient, it MUST reject the JWT.\"\n\n- [x] I found https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#section-3.11-2 confusing.  Here's the text:\n\"Per the definition of \"typ\" in Section 4.1.9 of [RFC7515], it is RECOMMENDED that the \"application/\" prefix be omitted from the \"typ\" value. Therefore, for example, the \"typ\" value used to explicitly include a type for a SET SHOULD be \"secevent+jwt\". When explicit typing is employed for a JWT, it is RECOMMENDED that a media type name of the format \"application/example+jwt\" be used, where \"example\" is replaced by the identifier for the specific kind of JWT.\"\nAs a JWT creator, should I be including \"application/\" in the typ value? I see recommendations for and against that, unless the media type name refers to something other than the value of the typ header. What am I missing?\n\n- [x] In https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#section-3.12 I missed the MUST here, as I jumped right to the list. I'd suggest a small formatting change to highlight the MUST. Can we do a newline to make it clearer? That would change:\n\"If more than one kind of JWT can be issued by the same issuer, the validation rules for those JWTs MUST be written such that they are mutually exclusive, rejecting JWTs of the wrong kind. To prevent substitution of JWTs from one context into another, application developers may employ a number of strategies:\"\nto\n\"If more than one kind of JWT can be issued by the same issuer, the validation rules for those JWTs MUST be written such that they are mutually exclusive, rejecting JWTs of the wrong kind. To prevent substitution of JWTs from one context into another, application developers may employ a number of strategies:\"\n\n- [x] In https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#section-3.13\nthat 600k OWASP iteration recommendation value changes over time. Do you want this text to be more broadly applicable in the future? (Not sure how this kind of thing is handled in general.) If so, could change this from:\n\"\"[OWASP-Password-Storage] states that an iteration count of 600,000 is required when using HMAC-SHA-256 to achieve FIPS-140 compliance. Thus, rejecting inputs with a p2c (PBES2 Count) value over 1,200,000 (double that) is RECOMMENDED.\"\nto\n\"[OWASP-Password-Storage] states a specific iteration count (600,000 at time of publishing) is required when using HMAC-SHA-256 to achieve FIPS-140 compliance. Rejecting inputs with a p2c (PBES2 Count) value larger than double the recommended OWASP value is RECOMMENDED.\"\n\n- [x] In https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#section-3.14 it is unclear to me if this if this is for the JWT as encoded or the decoded value? I think encoded, but am not sure. Do you want to reference base64 url encoding here? as mentioned in 7515 and by https://datatracker.ietf.org/doc/html/rfc4648#section-5\n\ncc: @mooreds",
      "createdAt": "2025-07-14T20:30:33Z",
      "updatedAt": "2025-09-29T14:28:40Z",
      "closedAt": "2025-09-29T14:28:40Z",
      "comments": [
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "Partially addressed by #23.",
          "createdAt": "2025-09-21T17:13:02Z",
          "updatedAt": "2025-09-21T17:13:02Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "> Is the attack outlined here https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#section-2.5 the same as\nhttps://neilmadden.blog/2022/04/19/psychic-signatures-in-java/ ? If so, maybe that is a better link?\n\nOne is JWS and one is JWE, and there's 5 years between them.",
          "createdAt": "2025-09-22T11:55:26Z",
          "updatedAt": "2025-09-22T11:55:26Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "> In https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#section-3.2 you quote the RFC which mentions SHOULD but then you follow it up with MUST. I find that confusing. I'd remove the first paragraph or at least this sentence: \"Even if a JWS can be successfully validated, unless the algorithm(s) used in the JWS are acceptable to the application, it SHOULD consider the JWS to be invalid.\" because then you remove the SHOULD/MUST confusion I had.\n\nI think the RFC 7515 does support the following paragraph, despite the SHOULD/MUST confusion. BTW the first paragraph is about receivers and the second about senders. Anyway, keeping the text as-is.",
          "createdAt": "2025-09-22T12:00:15Z",
          "updatedAt": "2025-09-22T12:00:15Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "> I found https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#section-3.11-2 confusing. Here's the text:\n\"Per the definition of \"typ\" in Section 4.1.9 of [RFC7515], it is RECOMMENDED that the \"application/\" prefix be omitted from the \"typ\" value. Therefore, for example, the \"typ\" value used to explicitly include a type for a SET SHOULD be \"secevent+jwt\". When explicit typing is employed for a JWT, it is RECOMMENDED that a media type name of the format \"application/example+jwt\" be used, where \"example\" is replaced by the identifier for the specific kind of JWT.\"\nAs a JWT creator, should I be including \"application/\" in the typ value? I see recommendations for and against that, unless the media type name refers to something other than the value of the typ header. What am I missing?\n\nI'm also confused. @selfissued WDYT?",
          "createdAt": "2025-09-22T12:10:27Z",
          "updatedAt": "2025-09-22T12:10:27Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "> \"Per the definition of \"typ\" in Section 4.1.9 of [RFC7515], it is RECOMMENDED that the \"application/\" prefix be omitted from the \"typ\" value. Therefore, for example, the \"typ\" value used to explicitly include a type for a SET SHOULD be \"secevent+jwt\". When explicit typing is employed for a JWT, it is RECOMMENDED that a media type name of the format \"application/example+jwt\" be used, where \"example\" is replaced by the identifier for the specific kind of JWT.\"\n\nRephrase: the first sentence is \"typ\", the second is about media type. We could add \"while omitting application/\" but need better clarification.",
          "createdAt": "2025-09-22T14:09:26Z",
          "updatedAt": "2025-09-22T14:09:26Z"
        },
        {
          "author": "mooreds",
          "authorAssociation": "NONE",
          "body": "> Rephrase: the first sentence is \"typ\", the second is about media type. We could add \"while omitting application/\" but need better clarification.\n\nAh, so the first section, where you don't need the `application/` prefix is for the `typ` key in the header, whereas the second is the media type name?\n\nThat makes sense. \n\nMaybe rewrite it to:\n\n> Per the definition of \"typ\" in Section 4.1.9 of [[RFC7515](https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#RFC7515)], it is RECOMMENDED that the \"application/\" prefix be omitted from the \"typ\" Header Parameter value. Therefore, for example, the \"typ\" value used to explicitly include a type for a SET SHOULD be \"secevent+jwt\". \n> \n> When explicit typing is employed for a JWT, it is RECOMMENDED that a media type name of the format \"application/example+jwt\" be used, where \"example\" is replaced by the identifier for the specific kind of JWT. Therefore, for example, the media type name for a SET SHOULD be \"application/secevent+jwt\".",
          "createdAt": "2025-09-22T21:35:24Z",
          "updatedAt": "2025-09-22T21:35:24Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "All remaining comments addressed by #25.",
          "createdAt": "2025-09-23T13:00:27Z",
          "updatedAt": "2025-09-23T13:00:41Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDONgvdIs7AqFcH",
      "title": "JWTs issued for one individual must not be usable by another individual with a complicity between these individuals",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/issues/15",
      "state": "CLOSED",
      "author": "Denisthemalice",
      "authorAssociation": "NONE",
      "assignees": [
        "dickhardt"
      ],
      "labels": [],
      "body": "The title of this document is JSON Web Token Best Current Practices. Its goal is \"to provide actionable guidance leading to secure implementation and deployment of JWTs\" and \"to facilitate *secure implementation* and deployment of JWTs\" (Introduction).\n\nSection 2 (Threats and Vulnerabilities) lists some known and possible problems with JWT implementations and deployments. \n\nSection 2.7 (Substitution Attacks) states:\n\n> There are attacks in which one recipient will be given a JWT that was intended for it and will attempt to use it at a different recipient for which that JWT was not intended.\n\nThis relates to the audience of the JWT.\n\nSection 2.8 (Cross-JWT Confusion) states:\n\n> As JWTs are being used by more different protocols in diverse application areas, it becomes increasingly important to prevent cases of JWT tokens that have been issued for one purpose being subverted and used for another. \n\n\nThe concept of \"purpose\" is inexistent in JWT-SD and would need to be clarified.\n\nThis draft is concentrating on the structure of JWTs, but is ignoring the context in which JWTs are requested, obtained and then used. \n\nSD-JWTs defined SD-JWTs *formats* for two flows: \n\n     a) when an issuer issues a SD-JWT including all Disclosures,\n     b) when a verifier presents SD-JWT or SD-JWT+KB including selected Disclosures.\n\nHowever, SD-JWT does not define which *protocols* can be used to carry these *data formats*.\n\nHence, threats and vulnerabilities that can arise in these protocols are not considered, nor addressed. \nThis means that the current content of this draft while explicit targeted to \"Developers of specifications that rely on JWTs, \nboth inside and **outside the IETF**\" is incomplete.\n\nTwo important \"specifications that rely on JWTs outside the IETF\" are:\n\n> \"OID4VCI\": OpenID for Verifiable Credential Issuance - draft 16\n> https://openid.net/specs/openid-4-verifiable-credential-issuance-1_0.html\n> \n> \"OID4VP\": \"OpenID for Verifiable Presentations 1.0\" which defines a protocol for requesting and presenting Credentials (published on 9 July 2025). It defines a mechanism on top of OAuth 2.0 to allow presentation of claims in the form of Verifiable Credentials as part of the protocol flow. https://openid.net/specs/openid-4-verifiable-presentations-1_0.html\n\nThese two OpenID specifications contain many optional features. This makes difficult for implementers to select a right combination that allows to develop a secure implementation.\n\nWhen using selective disclosure of claims, it is important to prevent cases where JWTs issued for one individual would be usable by another individual with a complicity between these individuals. In some cases, this issue is identified as a \"relay attack\".\n\nThis issue has not been identified in the documents produced by the OAuth WG (nor the SPICE WG), nor in OID4VP.\n\nOID4VP defines protocols for requesting and presenting Credentials. It is not explicitly said that these protocols must be supported by a single application and that the end-user using the device supporting that application SHALL NOT be able to modify it or to use its \"key store\" by downloading a rogue application and then using these keys with it.\n\nOnce this issue is identified, it needs to be addressed in a section called \"implementation considerations\" which, unfortunately, is inexistent in the proposed draft.\n\nThis topic is highly dependent upon the type of the device, however, general considerations apply.\n\n\n",
      "createdAt": "2025-07-15T13:25:23Z",
      "updatedAt": "2025-11-17T15:24:03Z",
      "closedAt": "2025-11-17T15:24:03Z",
      "comments": [
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "@Denisthemalice \n\n> However, SD-JWT does not define which protocols can be used to carry these data formats.\n\n> Hence, threats and vulnerabilities that can arise in these protocols are not considered, nor addressed.\nThis means that the current content of this draft while explicit targeted to \"Developers of specifications that rely on JWTs,\nboth inside and outside the IETF\" is incomplete.\n\nWhat specifically are you suggesting should be added to the JWT BCP?  I participated in SD-JWT and provided guidance on JWT best practices to be included in SD-JWT. What did we miss?\n\n\n> These two OpenID specifications contain many optional features. This makes difficult for implementers to select a right combination that allows to develop a secure implementation.\n\nAre you suggested we provide advice no not including optional features?  While I agree there may be challenges in \"many optional features\", that is decision that looks out of scope as a best practice as it is dependent on the use cases a specification is trying to solve and \"many optional features\" may be the right choice. Do you have suggested text to make the discussion more concrete?\n\n\n\n",
          "createdAt": "2025-09-14T13:37:56Z",
          "updatedAt": "2025-09-14T13:37:56Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "@Denisthemalice checking in you saw this -- we will close if we don't receive additional context",
          "createdAt": "2025-09-21T18:04:13Z",
          "updatedAt": "2025-09-21T18:04:13Z"
        },
        {
          "author": "Denisthemalice",
          "authorAssociation": "NONE",
          "body": "The key point is making sure that the private keys that are generated by the Holder application are used \"appropriately\" by a \"trusted \" Holder application. These private keys are used by two different protocols: \n\na) by an Holder - Issuer protocol before the user requests a SD-JWT to an Issuer and \nb) by an Holder - Issuer protocol when the user presents some claims contained in a SD-JWT to a Verifier.\n\nThe same Holder application shall be used for implementing these two protocols.\n\nThe security characteristics of the \"trusted\" application should be known : (a) by the Issuer but also (b) by the Verifier. \nThe EUDIW is using the concept of a \"wallet attestation\".\n\nWallet attestations can be verified using a set of trust anchors and a set of PKCs.\n\nThe owner of the device that supports the Holder application should not be able to modify that trusted application or to replace it by another application. In practice, this means that the device should not be rooted or jailed-broken, or if it has been rooted or jailed broken, the trusted Holder application should immediately cease to operate.\n\nThis the top of the iceberg for implementations considerations.\n\nWhen the Holder application presents a public key that will later be included into a SD-JWT, that Holder application should present to the Issuer an \"Holder application attestation\" that allows the Issuer to know the characteristics of the Holder application. The Holder application should also demonstrate the knowledge of the private key corresponding to the public key included into the Holder application attestation. \n\nSome protocols make that this feature optional. When it is optional, no guarantee can be obtained about the characteristics of the Holder application.\n\nFor the protocol b) that is used in the context of the Holder - Issuer protocol, two options are possible:\n\n1) take advantage of the fact that the Issuer can know the characteristics of the Holder application and once it has verified them, they can be included into a claim within the SD-JWT. Unfortunately at this moment, no claim has yet been requested to IANA to include them. A best practice should be to include them into a SD-JWT. This approach supports the concept of a transitive trust: If the Issuer can be trusted by the Verifier to verify the characteristics of the Holder application, then the Verifier can use this claim when it is present.\n\n2) implement an additional protocol between the Holder application and the Verifier that allows the Verifier to know the characteristics of the Holder application. However, privacy considerations should be considered to prevent Verifiers to link Holder applications using Holder application attestations. This would be far more complicated than the first option. While the second option should be mentioned, it should be deprecated.\n\nIf we draw a parallel between X.509 certificates and SD-JWTs, X.509 certificates can include CertificatePolicies. \nSD-JWTs should be able to include IssuerPolicies. \n\nAt this moment, we are not yet at the end of the story.\n\nSD-JWTs can be used in an on-line mode or in a proximity mode. For the moment, let us only consider an on-line mode involving an interaction with a web browser.\n\nIn the same way that only trusted Holder applications should be used, only trusted browsers applications should be used by trusted Holder applications. The trusted Holder applications should verify that it is in fact the case. \n\nWhen the device is a smart phone, considerations should also be given about the use of the TEEs, not only for the protection of the private keys but also for their use by appropriate trusted Holder applications.\n\nIf we want to securely deploy SD-JWTs, these best practices are currently missing and should be considered.\n\n",
          "createdAt": "2025-09-23T06:30:27Z",
          "updatedAt": "2025-09-23T06:30:27Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "@Denisthemalice am I understanding you correctly that you are proposing that the JWT BCP include language about the management of SD-JWT private keys?",
          "createdAt": "2025-09-23T08:48:55Z",
          "updatedAt": "2025-09-23T08:48:55Z"
        },
        {
          "author": "Denisthemalice",
          "authorAssociation": "NONE",
          "body": "No. It is more than simply the management of the private keys. \n\nIt is about the management of the private keys by an Holder application that runs on a device. Which trust relationships should there be between a web browser application and an Holder application ? Which parts of the Holder application should run in the RichOS and in the TEE ? What about the security characteristics of the RichOS and of the TEE ? \n",
          "createdAt": "2025-09-24T13:28:35Z",
          "updatedAt": "2025-09-24T13:28:35Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "> Which trust relationships should there be between a web browser application and an Holder application ? Which parts of the Holder application should run in the RichOS and in the TEE ? What about the security characteristics of the RichOS and of the TEE ?\n\n\nA best current practice does not create new practices -- it pull together practices that have been proven to be the best practices. \n\nWhat best practice are you suggesting would address the concerns you are raising?\n",
          "createdAt": "2025-09-24T14:00:40Z",
          "updatedAt": "2025-09-24T14:00:40Z"
        },
        {
          "author": "Denisthemalice",
          "authorAssociation": "NONE",
          "body": "The key point is that no \"best practice\" has currently been recommended to address this concern.\n\nIf this concern is not addressed, this will leave unsolved a major security concern which needs to be addressed when selective disclosure of claims is supported and the user cannot be uniquely identified.\n\nA sketch of the beginning of best practices is detailed in the previous comments.\n ",
          "createdAt": "2025-09-26T14:28:00Z",
          "updatedAt": "2025-09-26T14:28:00Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "I appreciate your desire to help secure deployments, but the BCP is a collection of existing, accepted practices that have been developed from experience and proven threats. Prescribing a speculative practice is not in our scope. ",
          "createdAt": "2025-09-26T14:56:43Z",
          "updatedAt": "2025-09-26T14:56:43Z"
        },
        {
          "author": "Denisthemalice",
          "authorAssociation": "NONE",
          "body": "draft-ietf-oauth-rfc8725bis-00 states:\n\n(...)\n\n2.  Threats and Vulnerabilities\n\n   This section lists some known and possible problems with JWT\n   implementations and deployments.\n\n     2.1.  Weak Signatures and Insufficient Signature Validation \n     2.2.  Weak Symmetric Keys \n     2.3.  Incorrect Use and Composition of Encryption and Signature\n     2.4.  Plaintext Leakage through Analysis of Ciphertext Length\n     2.5.  Insecure Use of Elliptic Curve Encryption\n     2.6.  Multiplicity of JSON Encodings\n     2.7.  Substitution Attacks\n     2.8.  Cross-JWT Confusion\n     2.9.  Indirect Attacks on the Server\n     2.10. Computation Cost of Unreasonable Number of Hash Iterations\n     2.11. Algorithm Verification Code Not Defensively Written\n     2.12. JWE Decompression Bomb Attack\n     2.13. JWT Format Confusion\n\nThe threat I mentioned is not listed in any of these sections.\n\nThe threat has been identified more than two years ago under the following title: Security of Trusty OS (TEE) Non-Secure World API.\nhttps://security.stackexchange.com/questions/269155/security-of-trusty-os-tee-non-secure-world-api\n\nThe question raised were the following: \n\n> How can the trusted application make sure that only selected applications from the Non-Secure World can access the port?\n> \n> Is there even a way how a trusted application can securely determine which application from the Non-Secure World connected to it?\n> \n\nIf a rogue application can be installed by the owner of a device and use the keys that should normally only be used by a specific trusted application, then another individual can take benefit of the cryptographic results produced by the TEE.\n\nThere are several ways to name that threat. For the time being, I have identified it under the following wording :\n\" JWTs issued for one individual must not be usable by another individual with a complicity between these individuals\".\n\nThis threat is particularly relevant when selective disclosure of claims is supported and the user cannot be uniquely identified.\n\ndraft-ietf-oauth-rfc8725bis-00 states:\n\n>    This BCP specification furthermore replaces the existing JWT BCP\n>    specification RFC 8725 to provide additional actionable guidance\n>    covering threats and attacks that have been discovered since RFC 8725\n>    was published.\n> \n> (...)\n> \n>    The goal of this document is to facilitate secure implementation and\n>    deployment of JWTs.\n\nIf we really want to \"facilitate secure implementation and deployment of JWTs\" covering threats and attacks that were not mentioned when RFC 8725 was published, we should not ignore that threat and we should indicate ways to counter it.",
          "createdAt": "2025-10-02T07:05:29Z",
          "updatedAt": "2025-10-02T07:05:29Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "@Denisthemalice \n\nThanks for raising this. The scenario you describe is absolutely a real-world threat, but it results from key-management and TEE isolation failures, not from any behavior specific to JWTs or JOSE.\n\nThe JWT BCP focuses narrowly on how to create, validate, and use JWTs safely (algorithm verification, claim validation, confusion/substitution prevention, cryptographic parameter limits, etc.).\n\nThe TEE scenario is an operational/platform issue: multiple applications are allowed to use the same signing key. JWTs (or any other token type) cannot defend against a compromised or overly-permissive key environment.\n\nTherefore this threat is out of scope for this document, and I am closing this issue. It is better covered by platform security guidance, key-attestation requirements, or the SD-JWT deployment BCP rather than the JWT BCP.\n\n",
          "createdAt": "2025-11-17T15:24:03Z",
          "updatedAt": "2025-11-17T15:24:03Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "I_kwDONgvdIs7Dv4RM",
      "title": "Review by Aaron Parecki",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/issues/17",
      "state": "CLOSED",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "selfissued"
      ],
      "labels": [],
      "body": "- [x] One application area in which JWTs are commonly used is representing digital identity information, such as OpenID Connect ID Tokens  [OpenID.Core] and OAuth 2.0  [RFC6749] access tokens and refresh tokens\n\n    Change to \"representing authorization or identity information, such as\nOAuth 2.0 access tokens [RFC9068] and OpenID Connect ID Tokens\n[OpenID.Core]\"\n\n    It is not common practice to use JWTs for refresh tokens, since\nrefresh tokens are only consumed by the issuer, whereas access tokens\nare consumed by the resource server which is a separate role from the\nauthorization server that issues them. Also updated the reference to\nthe JWT access token spec.\n\n- [x] if a JWT is cryptographically protected end-to-end by a transport layer, such as TLS using cryptographically current algorithms, there may be no need to apply another layer of cryptographic protections to the JWT. In such cases, the use of the \"none\" algorithm can be perfectly acceptable.\n\n    This makes it sound like it's acceptable to send alg none JWTs as\naccess tokens over TLS, which is obviously not true. I would suggest\nremoving all references to alg none being acceptable. If there is an\nactual concrete use case for alg none JWTs, list it out explicitly,\npreferably to a reference of a spec/profile that uses it.\n\n- [x] Section 3.3 mentions the term \"Nested JWT\" capitalized, but this is\nthe first occurrence of the term in the document. Add a reference to\nwhere Nested JWT is defined, or change to lowercase if the intent is\nto mention the general concept of nested JWTs.\n\n- [x] The means of determining the keys owned by an issuer is application-specific. As one example, OpenID Connect  [OpenID.Core] issuer values are \"https\" URLs that reference a JSON metadata document that contains a \"jwks_uri\" value that is an \"https\" URL from which the issuer's keys are retrieved as a JWK Set [RFC7517]. This same mechanism is used by  [RFC8414].\n\n- [x] Swap the mentions of RFC8414 and OpenID Connect: \"As one example,\nAuthorization Server Metadata [RFC8414] issuer values are .... The\nsame mechanism is used by OpenID Connect [OpenID.Core].\"\n\n- [x] Similarly, when the JWT contains a \"sub\" (subject) claim, the application MUST validate that the subject value corresponds to a valid subject and/or issuer-subject pair at the application\n\n    This would benefit from an explicit reference to Section 4.15 of\nRFC9700 https://datatracker.ietf.org/doc/html/rfc9700#section-4.15\nwhich talks about the possibility of client_id vs user identifier\nconfusion.\n\n- [x] Section 3.10: change \"whitelist\" to \"allowlist\". There is already a\nprior use of \"allowlist\" in the doc, so I assume this was\nunintentional.\n\n- [x] Also in section 3.10, mention that the AS should check what the\nhostname resolves to and avoid making a request if it resolves to a\nloopback or internal IP address. (e.g. someone uses the value\n\"attacker.example.com/etc/passwd\" as the jwks_uri, but adds a DNS\nentry for \"attacker.example.com\" to resolve to \"127.0.0.1\" or other\ninternal IP address ranges.\n\n- [x] Section 3.11: \"Sometimes, one kind of JWT can be confused for another.\"\n\n    This is kind of vague and would benefit from more explicit examples.\n\nCC: @aaronpk",
      "createdAt": "2025-08-01T14:18:38Z",
      "updatedAt": "2025-11-07T17:47:10Z",
      "closedAt": "2025-11-07T17:47:10Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Thanks, I reviewed the PR and checked off the changes addressed.",
          "createdAt": "2025-11-07T16:58:26Z",
          "updatedAt": "2025-11-07T16:58:26Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Thanks for the followup comments in #27, I am happy with the changes",
          "createdAt": "2025-11-07T17:47:10Z",
          "updatedAt": "2025-11-07T17:47:10Z"
        }
      ]
    },
    {
      "number": 18,
      "id": "I_kwDONgvdIs7FIwoP",
      "title": "Need a \"Changes from RFC8725\" section",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/issues/18",
      "state": "CLOSED",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "selfissued"
      ],
      "labels": [],
      "body": "The doc history section is insufficient, and is not published with the RFC.",
      "createdAt": "2025-08-10T09:52:37Z",
      "updatedAt": "2025-09-22T14:03:46Z",
      "closedAt": "2025-09-22T14:03:45Z",
      "comments": []
    },
    {
      "number": 19,
      "id": "I_kwDONgvdIs7HqdTX",
      "title": "Representation of time values to void the 2038 bug",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/issues/19",
      "state": "CLOSED",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "yaronf"
      ],
      "labels": [],
      "body": "Per ChatGPT, this is not a problem in mainstream systems, but remains a real problem in IOT. Quoting:\n\nShort answer: in mainstream server/client JOSE stacks, **no**\u2014current libraries do **not** use 32-bit integers for `NumericDate`. But in **embedded** ecosystems you can still encounter effective 32-bit limits because the platform\u2019s `time_t` (or equivalent) is 32-bit, and some Arduino/RTOS JWT implementations inherit that.\n\n### What I can confirm today\n\n* **Embedded/RTOS platforms still ship 32-bit `time_t`.** For example, Arduino environments and ESP8266 builds commonly use 32-bit (often signed) `time_t`, which overflows in 2038. ([[Arduino Forum](https://forum.arduino.cc/t/combining-int-and-time-t/907182?utm_source=chatgpt.com)][1], [[GitHub](https://github.com/esp8266/Arduino/issues/4948?utm_source=chatgpt.com)][2])\n* **JWT libraries exist for those platforms.** Several Arduino JWT libraries target AVR/ESP-class boards (which therefore inherit the 32-bit epoch limit unless they store timestamps in a wider type). ([[GitHub](https://github.com/Ant2000/CustomJWT?utm_source=chatgpt.com)][3], [[about.gitlab.com](https://gitlab.com/petrhu/ArduinoJWT/blob/master/examples/simple_JSON_jwt/simple_JSON_jwt.ino?utm_source=chatgpt.com)][4])\n* **Some projects still file bugs about 32-bit time usage.** The Zephyr RTOS had an open issue around use of 32-bit `time_t`. ([[GitHub](https://github.com/zephyrproject-rtos/zephyr/issues/58681?utm_source=chatgpt.com)][5])\n\n### Mainstream stacks (generally safe)\n\nModern general-purpose platforms use 64-bit time or IEEE-754 doubles for JSON numbers:\n\n* **Windows/MSVC** defaults `time_t` to 64-bit; 32-bit can be forced but is discouraged because it breaks after Jan 18, 2038. ([[Microsoft Learn](https://learn.microsoft.com/en-us/previous-versions/1f4c8f33%28v%3Dvs.140%29?utm_source=chatgpt.com)][6])\n* Historical bugs in popular JWT libs (e.g., using Java `Integer` for dates) were fixed years ago to use 64-bit `Long`. ([[GitHub](https://github.com/auth0/java-jwt/issues/132?utm_source=chatgpt.com)][7])\n\n### Practical guidance\n\n* If you\u2019re using **Arduino/ESP/RTOS** JWT code, **audit** how it parses/serializes `exp/nbf/iat`: confirm it uses a 64-bit type (or a double) end-to-end, not `time_t`/`long` that is 32-bit on that target.\n* In \\*\\*Java/C#/**Node/Python**, you\u2019re typically safe, but unit-test with a token whose `exp` is beyond **2038-01-19** to catch regressions.\n* If you control the schema, consider allowing **fractional seconds** (per RFC 7519\u2019s allowance) to encourage use of floating-point/64-bit representations.\n\n**Bottom line:** Current, maintained JOSE/JWT libraries for desktop/server use do not intentionally use 32-bit `NumericDate`, but **embedded implementations can still be constrained to 32-bit by their platform**, so review those carefully. ([[Arduino Forum](https://forum.arduino.cc/t/combining-int-and-time-t/907182?utm_source=chatgpt.com)][1], [[GitHub](https://github.com/esp8266/Arduino/issues/4948?utm_source=chatgpt.com)][2])\n\n[1]: https://forum.arduino.cc/t/combining-int-and-time-t/907182?utm_source=chatgpt.com \"Combining int and time_t - Programming - Arduino Forum\"\n[2]: https://github.com/esp8266/Arduino/issues/4948?utm_source=chatgpt.com \"time_t typedef should be unsigned 32-bit (to avoid year 2038 problem)\"\n[3]: https://github.com/Ant2000/CustomJWT?utm_source=chatgpt.com \"GitHub - Ant2000/CustomJWT\"\n[4]: https://gitlab.com/petrhu/ArduinoJWT/blob/master/examples/simple_JSON_jwt/simple_JSON_jwt.ino?utm_source=chatgpt.com \"examples/simple_JSON_jwt/simple_JSON_jwt.ino \u00b7 master \u00b7 Petr ...\"\n[5]: https://github.com/zephyrproject-rtos/zephyr/issues/58681?utm_source=chatgpt.com \"[Coverity CID: 316011] Use of 32-bit time_t in lib/os/timeutil.c ...\"\n[6]: https://learn.microsoft.com/en-us/previous-versions/1f4c8f33%28v%3Dvs.140%29?utm_source=chatgpt.com \"time, _time32, _time64 | Microsoft Learn\"\n[7]: https://github.com/auth0/java-jwt/issues/132?utm_source=chatgpt.com \"Timestamps are limited by Integer/int to 2038-01-19T04:14:07 ... - GitHub\"",
      "createdAt": "2025-08-24T18:46:46Z",
      "updatedAt": "2025-09-21T16:51:39Z",
      "closedAt": "2025-09-21T16:51:39Z",
      "comments": [
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "https://www.rfc-editor.org/rfc/rfc8259#section-6 says:\n\n> Note that when such software is used, numbers that are integers and\n> are in the range [-(2**53)+1, (2**53)-1] are interoperable in the\n> sense that implementations will agree exactly on their numeric\n> values.\n\nSo this isn't a problem for JSON - which is what the spec uses.  We should say that.",
          "createdAt": "2025-09-08T14:26:34Z",
          "updatedAt": "2025-09-08T14:26:34Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "Even for smaller systems the links seem to be old or obsolete. Arduino is not all 64-bit time yet, but parts of the ecosystem are already there and those that are still 32-bit will feel the pain even without our help. Closing.",
          "createdAt": "2025-09-21T16:51:39Z",
          "updatedAt": "2025-09-21T16:51:39Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDONgvdIs7Ik8Fd",
      "title": "Markdown magic",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/issues/20",
      "state": "CLOSED",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Add a `venue` section to the YAML at the top of the doc, as well as:\n\n```\n{::boilerplate bcp14-tagged}\n```\nin the Conventions section.",
      "createdAt": "2025-08-29T01:27:23Z",
      "updatedAt": "2025-09-08T14:32:49Z",
      "closedAt": "2025-09-08T14:32:49Z",
      "comments": []
    },
    {
      "number": 24,
      "id": "I_kwDONgvdIs7NEasV",
      "title": "In https://www.ietf.org/archive/id/draft-sheffer-oauth-rfc8725bis-01.html#name-weak-symmetric-keys perhaps you want to mention this open source project which cracks JWTs signed with a weak HMAC key: https://github.com/brendan-rius/c-jwt-cracker",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/issues/24",
      "state": "CLOSED",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-09-22T11:28:42Z",
      "updatedAt": "2025-09-22T11:46:23Z",
      "closedAt": "2025-09-22T11:46:23Z",
      "comments": []
    },
    {
      "number": 29,
      "id": "I_kwDONgvdIs7eFNwf",
      "title": "Brian's comment - WGLC - alg:none",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/issues/29",
      "state": "CLOSED",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Yaron: Adding to Mike\u2019s response: the BCP, already in the published RFC8725, includes a SHOULD NOT for RSA-PKCS1 v1.5. And it was published 4 years before the \u201cdeprecate\u201d draft.\n\nBrian: Yes and even back in 2020ish the original RFC8725 probably should have been stronger about discouraging RSAES-PKCS1-v1_5. \n\nMy rationale for suggesting a reference to the \"deprecate\" draft, however, was primarily about wanting to see proper and accountable guidance regarding the treatment of \"alg\":\"none\", which I believe is long overdue. The \"deprecate\" draft was well ahead of the RFC8725bis draft in the document lifecycle when that suggestion was made. I don't believe the cited \"precedent\" around RFC9700 is really applicable to this case anyway. And even if the \"deprecate\" draft continues to be [held up unecessarly](https://datatracker.ietf.org/doc/minutes-124-jose-202511051430/), an informative downref would be totally reasonable. \n\nI did say [here](https://mailarchive.ietf.org/arch/msg/jose/wBQR1eCcZ4rpqsPV2qJ8NCnT9Fk/) that I believe \"alg\":\"none\" has \"caused immeasurable and irreparable harm\" but that's maybe too defeatist. I do think there's still some value to be found in work that endeavors to fix past mistakes. The RFC8725bis draft should take the opportunity to try.\n\nCC: @bc-pi ",
      "createdAt": "2025-12-13T12:30:25Z",
      "updatedAt": "2026-01-12T15:20:30Z",
      "closedAt": "2026-01-12T15:20:30Z",
      "comments": [
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "Per the [mailing list discussion](https://mailarchive.ietf.org/arch/msg/oauth/fPW14HPAi3CwIqczP6sOKJIU-Do/) on this topic:\n> There\u2019s precedent in OAuth for not holding up publishing a BCP because other developments may update the BCP later.  In particular, we decided not to hold the OAuth Security BCP [RFC 9700] until we\u2019d addressed already known vulnerabilities, including the one being addressed in rfc7523bis.  Our logic was that it is better to publish the BCP in a timely fashion to get a set of useful information out to people and that the BCP will be updated when the mitigations for additional vulnerabilities are settled.\n\nI'll note that RFC 9700 does not include an informative reference to rfc8725bis, even though rfc8725bis documents an actionable security vulnerability and a proposed best practice for preventing it.  Both were known before draft-ietf-oauth-security-topics became RFC 9700.  It was thought to be better to publish the set of recommendations already in the draft and then update the BCP as new recommendations became final.  I believe that's the right course to follow here too.  BCPs are meant to be updated, if and when new best current practices are developed.\n\nAs for \"proper and accountable guidance regarding the treatment of \"alg\":\"none\"\", I'll note that RFC 8725 already provided strong and actionable guidance specifically about \"alg\":\"none\":\n> JWT libraries SHOULD NOT consume JWTs using \"none\" unless explicitly requested by the caller.\n\nSo when the existing BCP guidance is followed, unless the recipient explicitly says that it wants to consume tokens using \"alg\":\"none\", misuse is already impossible.\n",
          "createdAt": "2025-12-15T02:35:19Z",
          "updatedAt": "2025-12-15T02:35:19Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "@bc-pi Is there a change you're proposing to our existing normative guidance,\n\n> JWT libraries SHOULD NOT consume JWTs using \"none\" unless explicitly requested by the caller.",
          "createdAt": "2025-12-15T15:46:03Z",
          "updatedAt": "2025-12-15T15:46:03Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "NONE",
          "body": "> [@bc-pi](https://github.com/bc-pi) Is there a change you're proposing to our existing normative guidance,\n> \n> > JWT libraries SHOULD NOT consume JWTs using \"none\" unless explicitly requested by the caller.\n\nYes. Make it stronger. Reference https://datatracker.ietf.org/doc/draft-ietf-jose-deprecate-none-rsa15/. And change the tone of the text to acknowledge that \"alg\":\"none\" as the specification design mistake that it was and stop putting the blame on implementations. \n",
          "createdAt": "2025-12-17T18:19:45Z",
          "updatedAt": "2025-12-17T18:19:45Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "@bc-pi I agree this was both a design issue in the RFC and a problem with implementations. However I don't think it is our job in the current document to atone for sins of the past.\n\nDraft-deprecate is stuck in the working group. Regardless of what we think about this situation, it is not useful to speculate on the exact guidance that it will contain if/when it is finally published.\n\nGiven what little we have to work with, let me suggest a change.\n\nOld text:\n\n> The \"none\" algorithm should only be used when the JWT is cryptographically protected by other means. JWTs using \"none\" are often used in application contexts in which the content is optionally signed. The URL-safe claims representation and processing in this context can be the same in both the signed and unsigned cases. JWT libraries SHOULD NOT generate JWTs using \"none\" unless explicitly requested to do so by the caller. Similarly, JWT libraries SHOULD NOT consume JWTs using \"none\" unless explicitly requested by the caller.\n\nNew text:\n\n> Inclusion of the \"none\" algorithm in standards and JOSE implementations resulted in numerous vulnerabilities. RFC 7519 included \"none\" in its list of must-implement algorithms, and the current document updates this guidance to remove \"none\" from that list. Dependent standards and implementations that resorted to \"none\" because of the existence of other security controls (e.g. when sending tokens over an encrypted transport) SHOULD switch to a cryptographically signed JWT; otherwise they SHOULD replace the JWS/JWT by a base64url-encoded JSON object with no padding. New implementations SHOULD NOT support \"none\" unless required for backward compatibility.\n\n>  JWT libraries SHOULD NOT generate JWTs using \"none\" unless explicitly requested to do so by the caller. Similarly, JWT libraries SHOULD NOT consume JWTs using \"none\" unless explicitly requested by the caller.\n",
          "createdAt": "2025-12-20T14:29:55Z",
          "updatedAt": "2025-12-20T14:29:55Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "@yaronf, I can't agree with your proposed text, because breaking existing deployments of JWTs is not a best current practice.  We should only be putting established best practices into the draft, as we have been discussing in this issue in others, and on the mailing list.",
          "createdAt": "2025-12-20T21:16:46Z",
          "updatedAt": "2025-12-20T21:16:46Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "@selfissued RFC 8725 is marked \"Updates 7519\" so quite formally, we have a license to change the protocol (a.k.a., \"breaking changes\") if that's required to ensure the community's current understanding of security best practices.\n\nI don't love breaking changes, and I have great respect for the community that formed around JOSE and no wish to disrupt it, but sometimes breaking changes cannot be avoided.\n\nAlso, thank you for adding a reference to the draft.",
          "createdAt": "2025-12-21T15:17:33Z",
          "updatedAt": "2025-12-21T15:17:33Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "Reopening the issue: I did approve the PR that added the reference but we need to discuss whether this fully addresses the core issue.",
          "createdAt": "2026-01-04T17:33:44Z",
          "updatedAt": "2026-01-04T17:33:44Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "> Dependent standards and implementations that resorted to \"none\" because of the existence of other security controls (e.g. when sending tokens over an encrypted transport) SHOULD switch to a cryptographically signed JWT; otherwise they SHOULD replace the JWS/JWT by a base64url-encoded JSON object with no padding. New implementations SHOULD NOT support \"none\" unless required for backward compatibility.\n\nIs this net new language, or is this taken from somewhere else? \n\nI'm not keen on net new language -- telling existing implementations they SHOULD make breaking changes does not seem like good advice. \n\nWhile I have the view that \"alg\":\"none\" was a mistake -- we can't break existing, working deployments -- we can of course tell new things they SHOULD NOT use \"alg\":\"none\"",
          "createdAt": "2026-01-07T12:18:53Z",
          "updatedAt": "2026-01-07T12:18:53Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "@yaronf wrote:\n> @selfissued RFC 8725 is marked \"Updates 7519\" so quite formally, we have a license to change the protocol (a.k.a., \"breaking changes\") if that's required to ensure the community's current understanding of security best practices.\n> I don't love breaking changes, and I have great respect for the community that formed around JOSE and no wish to disrupt it, but sometimes breaking changes cannot be avoided.\n\nMy comment at https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/pull/33#issuecomment-3679132933 also applies here:\n> Actually, the BCP doesn't update JWE [RFC 7516]. It's not within our remit to make breaking changes to a spec in another working group. That would need to be done by new spec work in the JOSE working group, with consensus of that working group. It is within our scope to recommend that problematic features not be used.\n\nIt's not within our remit to make breaking changes in a specification in a different working group.  The good news is that the JOSE working group has already taken up this particular issue.  We've referenced that work-in-progress informationally.\n\nI believe that #34 therefore completed our job on this issue, and it should be re-closed on that basis.",
          "createdAt": "2026-01-07T14:42:09Z",
          "updatedAt": "2026-01-07T14:42:09Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "IMO we already made a breaking change in 8725 when we said that:\n\n> JWT libraries SHOULD NOT generate JWTs using \"none\" unless explicitly requested to do so by the caller. Similarly, JWT libraries SHOULD NOT consume JWTs using \"none\" unless explicitly requested by the caller.\n\nThis is a breaking change because code that's using libraries that were modified to follow our advice would have to change.\n\nLet me remind ourselves that:\n\n- 7519 includes None as a MUST.\n- None became a major security fiasco.\n\nRFC 8725 is totally unclear about \"this is no longer a MUST\" and I think it's on us to clarify this point.",
          "createdAt": "2026-01-08T17:50:03Z",
          "updatedAt": "2026-01-08T17:50:03Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "@yaronf -- your proposed language is telling existing implementations they SHOULD change how they work -- that they should no longer use \"alg\":\"none\" and use base64url-encoded JSON. That is not the same as libraries only supporting \"none\" when explicitly requested per your last message. ",
          "createdAt": "2026-01-09T06:13:57Z",
          "updatedAt": "2026-01-09T06:13:57Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed between the editors. The current text should work well for the expected audience of this RFC, also, we added a reference to the deprecate-none draft. Closing.",
          "createdAt": "2026-01-12T15:20:30Z",
          "updatedAt": "2026-01-12T15:20:30Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "I_kwDONgvdIs7eFOfa",
      "title": "Brian's WGLC comment - explicit typing",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/issues/30",
      "state": "CLOSED",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Regarding explicit typing, splitting topics as per [this message](https://mailarchive.ietf.org/arch/msg/oauth/9iDsDNx8kkpBR4Gib5UbRNNiSZ4/), I did say in the [message to the list back in August](https://mailarchive.ietf.org/arch/msg/oauth/wXCAE-FcUHDcv7bsvpsiI62NpGY/) that I wasn't sure how it could be improved at this point. But that's different from doing nothing. At a minimum, there should be some additional treatment around the limitations of applying it to existing protocols/profiles (in most cases doing so would either be a breaking change or forgo much of the value of it). Two open issues on OIDC ([2162](https://bitbucket.org/openid/connect/issues/2162/recommendation-to-the-use-of-explicit) / [2185](https://bitbucket.org/openid/connect/issues/2185/id-tokens-should-have-an-associated-media)), recent [work in rfc7523bis](https://github.com/oauth-wg/draft-ietf-oauth-rfc7523bis/issues/8), [this in openid-key-binding](https://github.com/dickhardt/openid-key-binding/issues/5), parts of [whatever happened here](https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/issues/15), a WIMSE discussion Yaron and I were in just last week, and more that I don't have reference to offhand certainly suggest there's need for more guidance and clarity in an update to the BCP. \n\nAs mentioned [here](https://github.com/oauth-wg/oauth-selective-disclosure-jwt/issues/327) and probably elsewhere, I'm not convinced that the use of the 'typ' header and media types has proven to be the best or even a good vehicle for explicit typing. So I am not a fan of continued advocacy of it as a best practice. But it is largely ingrained current practice that would likely be untenable to change now. I won't be so presumptuous as to suggest a major change there but having this in the mailing list archive will hopefully prove useful down the road somehow though.\n\nSome treatment of \"typ\":\"JWT\" would also be worthwhile in an update to the BCP. If the construct provides any meaningly useful value, it'd be nice for the BCP update to explain it, otherwise the document should discourage its use.\n\ncc: @bc-pi ",
      "createdAt": "2025-12-13T12:33:49Z",
      "updatedAt": "2025-12-15T15:52:32Z",
      "closedAt": "2025-12-15T15:52:32Z",
      "comments": []
    },
    {
      "number": 31,
      "id": "I_kwDONgvdIs7eFPCL",
      "title": "Brian's WGLC comment - compression",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/issues/31",
      "state": "CLOSED",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Regarding compression, as stated previously, I believe the current text around compression in JWE is a bit overreaching and lacking in useful guidance about when it is or is not reasonable to use. [Section 3.6](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-rfc8725bis-02#section-3.6) has a SHOULD NOT on compressing the JWE payload because it \"often reveals information about the plaintext\" but nothing about when the recommendation isn't actually applicable. [Section 2.4](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-rfc8725bis-02#section-2.4), which points to that 3.6, does have some more text about \"Plaintext Leakage through Analysis of Ciphertext Length\" but mostly in the context of HTTPS, which is, of course, a completely different protocol with different considerations. I don't claim expertise but the conditions and problems described don't seem applicable to archetypal JW/JWT usage. \n\nI anecdotally understand there's been implementation(s) that dropped support for the zip header, at least in part due to this text in RFC8725, which doesn't seem great for interop. Some recent SDO work like OpenID4VCI do have some [\"negotiation\" capabilities](https://openid.net/specs/openid-4-verifiable-credential-issuance-1_0.html#section-8.2-2.4.1) around it but that one is the exception rather than the rule, which again doesn't seem good for interop.\n\ncc: @bc-pi ",
      "createdAt": "2025-12-13T12:36:46Z",
      "updatedAt": "2026-01-12T15:18:05Z",
      "closedAt": "2026-01-12T15:18:05Z",
      "comments": [
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "Reacting to the above, we've had over 20 years [1] of attacks on encryption combined with compression, so I don't think a SHOULD NOT is out of place. And it's not just TLS, there have been attacks on IPsec as well. Both are different from JWE/JWT but I think for the majority of cases a SHOULD NOT is a reasonable approach. In particular library developers often don't have enough context to say whether the risk exists in applications that are built on top of them.\n\nNote that the original research is about both chosen-plaintext AND passive attacks, and the passive part might well apply to JWE.\n\nHaving said all that, I'm sure we could improve the text.\n\n[1] John Kelsey, \u201cCompression and Information Leakage of Plaintext,\u201d FSE 2002 (LNCS 2365, pp. 263\u2013276)",
          "createdAt": "2025-12-13T12:48:14Z",
          "updatedAt": "2025-12-13T12:48:14Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "Per the [mailing list discussion](https://mailarchive.ietf.org/arch/msg/oauth/fPW14HPAi3CwIqczP6sOKJIU-Do/) on this topic:\n> As asked on the OAuth office hours call on Monday, November 17, 2025, are there new JWT best practices that have emerged on this topic since RFC 8725 was published that you can cite that you believe should be included in the draft, Brian?  If so, please provide proposed text.\n\nI was also going to add the Kelsey reference to the draft in response to this discussion, but I see that it's already there.",
          "createdAt": "2025-12-15T02:34:24Z",
          "updatedAt": "2025-12-15T02:34:24Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "NONE",
          "body": "Yes, I am aware of that reference that's in the RFC and draft and the mailing list discussion. I'm asking to \"improve the text\" to provide meaningfully useful guidance and rationale.  \n\n\n",
          "createdAt": "2025-12-17T17:41:20Z",
          "updatedAt": "2025-12-17T17:41:20Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "I for one think that the current text is just fine and that adding exceptional cases would confuse readers more than it would help. Brian, could you please share text that you think would be better?",
          "createdAt": "2025-12-17T18:51:07Z",
          "updatedAt": "2025-12-17T18:51:07Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "I've thought about this some in the background.  It may have been on the OAuth office hours call, but a problem that Brian described is implementations removing their support for compression, which causes an interop problem if the sender uses it and the recipient can't process it.  (Yes, it was probably a bad idea for the sender to use it, which is primarily what the existing guidance is about.)\n\nI'm willing to write a note in this section describing the interop problem.  Let me take a crack at that.",
          "createdAt": "2025-12-17T19:43:18Z",
          "updatedAt": "2025-12-17T19:43:18Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "NONE",
          "body": "The potential interop issue is more a second order effect. But still relevant. ",
          "createdAt": "2025-12-17T20:06:44Z",
          "updatedAt": "2025-12-17T20:06:44Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree this is a breaking change in that sense. But so is deprecating `alg:none`.",
          "createdAt": "2025-12-17T20:07:12Z",
          "updatedAt": "2025-12-17T20:07:12Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "NONE",
          "body": "> I for one think that the current text is just fine and that adding exceptional cases would confuse readers more than it would help. Brian, could you please share text that you think would be better?\n\nMaybe after the holidays. I leave in about 15mins. But I don't honestly know how. I am just asking for actual contextually meaningful guidance and or rationale because what's there genuinely doesn't make sense to me.   ",
          "createdAt": "2025-12-17T20:33:47Z",
          "updatedAt": "2025-12-17T20:33:47Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "Brian\r\n\r\nOur job is not to create guidance \u2014 it is to collect best current practice\r\n\u2014 if you can articulate a best current practice we can explore including it\r\n\u2014 but it is unreasonable to ask us to create guidance \u2014 we are just\r\ncollecting it.\r\n\r\nOn Wed, Dec 17, 2025 at 9:34\u202fPM Brian Campbell ***@***.***>\r\nwrote:\r\n\r\n> *bc-pi* left a comment (oauth-wg/draft-ietf-oauth-rfc8725bis#31)\r\n> <https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/issues/31#issuecomment-3667053085>\r\n>\r\n> I for one think that the current text is just fine and that adding\r\n> exceptional cases would confuse readers more than it would help. Brian,\r\n> could you please share text that you think would be better?\r\n>\r\n> Maybe after the holidays. I leave in about 15mins. But I don't honestly\r\n> know how. I am just asking for actual contextually meaningful guidance and\r\n> or rationale because what's there genuinely doesn't make sense to me.\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/issues/31#issuecomment-3667053085>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AAFIGVSOCAQQW33SLWBNZ4D4CG44DAVCNFSM6AAAAACO55OQMCVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZTMNRXGA2TGMBYGU>\r\n> .\r\n> You are receiving this because you are subscribed to this thread.Message\r\n> ID: ***@***.***>\r\n>\r\n",
          "createdAt": "2025-12-17T20:42:22Z",
          "updatedAt": "2025-12-17T20:42:22Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "NONE",
          "body": "> Brian\n> \n> Our job is not to create guidance \u2014 it is to collect best current practice\n> \u2014 if you can articulate a best current practice we can explore including it\n> \u2014 but it is unreasonable to ask us to create guidance \u2014 we are just\n> collecting it.\n> \n\nDick,\n\nThe framing that a BCP update should not \u201ccreate guidance\u201d is hard to reconcile with the document itself, as well as with other well-established BCPs (e.g., [TLS](https://www.rfc-editor.org/info/bcp195) and [OAuth](https://www.rfc-editor.org/info/bcp240) security BCPs).\n\nThe [abstract of RFC 8725](https://datatracker.ietf.org/doc/html/rfc8725#abstract) explicitly states that it exists to provide \u201cactionable guidance,\u201d and [draft-ietf-oauth-rfc8725bis-02's abstract](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-rfc8725bis-02#abstract) goes further by stating that it replaces RFC 8725 to provide \"additional actionable guidance\". Moreover, the substantive content of both documents consists almost entirely of such guidance.\n\nGiven that context, characterizing requests for improved guidance as \u201cunreasonable\u201d seems misplaced. Providing guidance is central to what a BCP, and this BCP in particular, claims to do.\n\n",
          "createdAt": "2026-01-08T23:46:19Z",
          "updatedAt": "2026-01-08T23:46:19Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "Providing guidance is clearly the purpose of a BCP. \n\n**Creating** guidance is not the same as **providing** guidance.\n\nIf you have guidance that is accepted as a best current practice -- please provide. \n\nIf you think there is an issue that needs guidance, please start a conversation in the community to get consensus on guidance. ",
          "createdAt": "2026-01-09T06:09:24Z",
          "updatedAt": "2026-01-09T06:09:24Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 7,
      "id": "PR_kwDONgvdIs6TU96R",
      "title": "Case insensitivity",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/pull/7",
      "state": "MERGED",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This issue is mentioned in several sources but I couldn't find a good reference or a CVE.\r\n\r\nCloses #6.",
      "createdAt": "2025-04-21T17:55:18Z",
      "updatedAt": "2025-05-17T15:35:59Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "baseRefName": "main",
      "baseRefOid": "a77673ae22b8366274c42e04a44145217725f1ec",
      "headRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "headRefName": "ys-6",
      "headRefOid": "009db6d17b81040c8bf7cb8cca14aa72baf265a6",
      "closedAt": "2025-05-17T15:35:49Z",
      "mergedAt": "2025-05-17T15:35:49Z",
      "mergedBy": "yaronf",
      "mergeCommit": {
        "oid": "7e104a7798e8d375382967df02ca275e328dbebf"
      },
      "comments": [
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "The bug is not that there is a blacklist.  The bug is that case-insensitive comparisons were used.  The fix should be about that.",
          "createdAt": "2025-05-12T12:59:29Z",
          "updatedAt": "2025-05-12T12:59:29Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "> The bug is not that there is a blacklist. The bug is that case-insensitive comparisons were used. The fix should be about that.\r\n\r\nI agree on the principle. The value \"noNE\" should not be accepted by the library as a valid algorithm. But this was probably a problem in the JSON parser that was overeager to normalize JSON claims. As such it may be outside the JOSE library's control.  The mitigation is a proposed way to harden the library against such unknown issues.",
          "createdAt": "2025-05-17T15:29:55Z",
          "updatedAt": "2025-05-17T15:29:55Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDONgvdIs6l0ZYO",
          "commit": {
            "abbreviatedOid": "b7a8513"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-21T18:35:25Z",
          "updatedAt": "2025-04-21T18:35:25Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "If we're going to use the term \"blocklist\", we either need to define it or add a reference for it, as it's not a commonly understood term.  I would suggest rewording to not use the term, as that may result in text that's easier to read.",
              "createdAt": "2025-04-21T18:35:25Z",
              "updatedAt": "2025-04-21T18:35:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6l0Z_v",
          "commit": {
            "abbreviatedOid": "b7a8513"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-21T18:36:57Z",
          "updatedAt": "2025-04-21T18:36:58Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "The term \"Security Policy\" will mean different things than intended to some readers.\r\n\r\nMaybe change the title to something more like \"Algorithm Verification Code Not Defensively Written\".",
              "createdAt": "2025-04-21T18:36:58Z",
              "updatedAt": "2025-04-21T18:36:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6pxgyB",
          "commit": {
            "abbreviatedOid": "009db6d"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-05-17T15:30:36Z",
          "updatedAt": "2025-05-17T15:30:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 8,
      "id": "PR_kwDONgvdIs6TcKyL",
      "title": "Encryption/signature confusion",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/pull/8",
      "state": "MERGED",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #4.",
      "createdAt": "2025-04-22T13:27:00Z",
      "updatedAt": "2025-05-23T09:21:55Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "baseRefName": "main",
      "baseRefOid": "6ed92926d8726fa357eb1d62aba88e1945520d73",
      "headRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "headRefName": "ys-4",
      "headRefOid": "de175a4f5afaa5190f907f219a06fca0ca6e8ae2",
      "closedAt": "2025-05-23T09:21:55Z",
      "mergedAt": "2025-05-23T09:21:55Z",
      "mergedBy": "yaronf",
      "mergeCommit": {
        "oid": "41f1359749ae6ab35b87f45ebdf8003b4713e801"
      },
      "comments": [
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "> if you're accepting a JWE, you also need a private key in the JWK to decrypt the thing. So the attack (sending a JWE instead of a JWS) only works if there's a private key on the receiver's side.\r\n\r\nIt's true that the recipient needs a private key to decrypt the encrypted JWT.  But it's not true that the private key needs to be in the JWK.  Typically only the public keys would be in the JWK.  The private key would normally be privately held by the recipient - not published in a JWK.",
          "createdAt": "2025-05-17T15:47:44Z",
          "updatedAt": "2025-05-17T15:47:44Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "> > if you're accepting a JWE, you also need a private key in the JWK to decrypt the thing. So the attack (sending a JWE instead of a JWS) only works if there's a private key on the receiver's side.\r\n> \r\n> It's true that the recipient needs a private key to decrypt the encrypted JWT. But it's not true that the private key needs to be in the JWK. Typically only the public keys would be in the JWK. The private key would normally be privately held by the recipient - not published in a JWK.\r\n\r\nFirst, I'm quoting the researcher who reported the issue in #4. For more detail see slides 17-19 [here](https://i.blackhat.com/BH-US-23/Presentations/US-23-Tervoort-Three-New-Attacks-Against-JSON-Web-Tokens.pdf).\r\n\r\nAlso, the point is not that the private key is published along with the JWK, but that when the JWK is used locally in the receiver's call to the JOSE library, in includes the private key.",
          "createdAt": "2025-05-17T21:58:24Z",
          "updatedAt": "2025-05-17T21:58:24Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "Please add a history entry for this change.",
          "createdAt": "2025-05-21T22:43:23Z",
          "updatedAt": "2025-05-21T22:43:23Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "> Also, the point is not that the private key is published along with the JWK, but that when the JWK is used locally in the receiver's call to the JOSE library, in includes the private key.\r\n\r\nJWK is a format for a key. Libraries also take PEM format for the key as well -> 'JWK' is not a correct way to refer to the key -- not that it matters for this PR ",
          "createdAt": "2025-05-22T00:18:50Z",
          "updatedAt": "2025-05-22T00:49:27Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDONgvdIs6o3laS",
          "commit": {
            "abbreviatedOid": "0389dda"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-12T13:02:42Z",
          "updatedAt": "2025-05-12T13:02:43Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "```suggestion\r\nLibraries MUST allow the verifier to distinguish between JWS-signed and JWE-encrypted JWTs, enabling callers to accept only JWTs that meet their security criteria.\r\n```",
              "createdAt": "2025-05-12T13:02:42Z",
              "updatedAt": "2025-05-12T13:02:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6o40RM",
          "commit": {
            "abbreviatedOid": "0389dda"
          },
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-12T14:32:01Z",
          "updatedAt": "2025-05-12T14:32:01Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "That would allow the verifier to only accept JWS, if that's their policy.",
              "createdAt": "2025-05-12T14:32:01Z",
              "updatedAt": "2025-05-12T14:32:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6o42ec",
          "commit": {
            "abbreviatedOid": "0389dda"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-12T14:34:50Z",
          "updatedAt": "2025-05-12T14:34:50Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "```suggestion\r\n```\r\n\r\nThis is unrelated to the other changes in this PR.  Please remove it.\r\n\r\nThis also contradicts https://www.rfc-editor.org/rfc/rfc7519.html#section-11.2.",
              "createdAt": "2025-05-12T14:34:50Z",
              "updatedAt": "2025-05-12T14:42:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6o45j-",
          "commit": {
            "abbreviatedOid": "0389dda"
          },
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-12T14:38:49Z",
          "updatedAt": "2025-05-12T14:38:50Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "Move into a separate PR.\r\n\r\nThis would contradict https://www.rfc-editor.org/rfc/rfc7519.html#section-11.2",
              "createdAt": "2025-05-12T14:38:50Z",
              "updatedAt": "2025-05-12T14:41:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6pxabG",
          "commit": {
            "abbreviatedOid": "0389dda"
          },
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-17T14:48:27Z",
          "updatedAt": "2025-05-17T14:48:27Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "For the record, the following in RFC 7519 convinced me:\r\n\r\n> Note that potential concerns about security issues related to the order of signing and encryption operations are already addressed by the underlying JWS and JWE specifications; in particular, because JWE **only supports the use of authenticated encryption algorithms**, cryptographic concerns about the potential need to sign after encryption that apply in many contexts do not apply to this specification.",
              "createdAt": "2025-05-17T14:48:27Z",
              "updatedAt": "2025-05-17T14:48:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6pxf-K",
          "commit": {
            "abbreviatedOid": "bd1f190"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-17T15:27:28Z",
          "updatedAt": "2025-05-17T15:27:28Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "I don't understand what the phrase \"when the verifier's asymmetric key includes the private key\" is getting at.  How does this relate to the vulnerability?",
              "createdAt": "2025-05-17T15:27:28Z",
              "updatedAt": "2025-05-17T15:27:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6pxgJB",
          "commit": {
            "abbreviatedOid": "bd1f190"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-17T15:28:01Z",
          "updatedAt": "2025-05-17T15:28:02Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "```suggestion\r\nIn the more complicated use cases where confidentiality is required, some libraries that decrypt a JWE-encrypted JWT to obtain a JWS-signed object\r\n```",
              "createdAt": "2025-05-17T15:28:02Z",
              "updatedAt": "2025-05-17T15:28:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6pxiMv",
          "commit": {
            "abbreviatedOid": "bd1f190"
          },
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-17T15:41:01Z",
          "updatedAt": "2025-05-17T15:41:02Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "On the receiver side, if all you want is a JWS then you only need a public key in the JWK, to verify the signature.\r\n\r\nBut if you're accepting a JWE, you also need a private key in the JWK to decrypt the thing. So the attack (sending a JWE instead of a JWS) only works if there's a private key on the receiver's side.",
              "createdAt": "2025-05-17T15:41:01Z",
              "updatedAt": "2025-05-17T15:41:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6px1mf",
          "commit": {
            "abbreviatedOid": "782fb02"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-17T22:14:01Z",
          "updatedAt": "2025-05-17T22:14:02Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\nMost authentication use cases only require a simple signed JWT as their token. However verifiers don't always check that the received JWT is a signed JWS as opposed to an encrypted JWE structure. This can result in vulnerabilities when the verifier's library does not distinguish between successful decryption and successful signature validation {{CVE-2023-51774}}.\r\n```\r\n\r\nDelete the ambiguous phrase",
              "createdAt": "2025-05-17T22:14:01Z",
              "updatedAt": "2025-05-17T22:14:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qbPDv",
          "commit": {
            "abbreviatedOid": "782fb02"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-21T22:22:56Z",
          "updatedAt": "2025-05-21T22:22:56Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Please apply my suggestion deleting the ambiguous phrase, then I will approve.",
              "createdAt": "2025-05-21T22:22:56Z",
              "updatedAt": "2025-05-21T22:22:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qcC5Q",
          "commit": {
            "abbreviatedOid": "de175a4"
          },
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-05-22T00:53:59Z",
          "updatedAt": "2025-05-22T18:53:48Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "> in particular when the verifier's asymmetric key includes the private key\r\n\r\nI think I know what this means -- but I think it can be more crisp.\r\n```suggestion\r\nMost authentication use cases only require a simple signed JWT as their token. However verifiers don't always check that the received JWT is a signed JWS as opposed to an encrypted JWE structure. This can result in vulnerabilities, in particular when the verifier asymmetric key material includes both a public key and a private key, and when the verifier's library does not distinguish between successful decryption and successful signature validation {{CVE-2023-51774}}.\r\n```",
              "createdAt": "2025-05-22T00:53:59Z",
              "updatedAt": "2025-05-22T18:53:48Z"
            },
            {
              "originalPosition": 21,
              "body": "I provided a more crisp phrase -- I hope!",
              "createdAt": "2025-05-22T00:54:33Z",
              "updatedAt": "2025-05-22T18:53:48Z"
            },
            {
              "originalPosition": 21,
              "body": "I'm also fine with Mike's phrasing ... ",
              "createdAt": "2025-05-22T18:52:49Z",
              "updatedAt": "2025-05-22T18:53:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qoRHO",
          "commit": {
            "abbreviatedOid": "de175a4"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-05-22T22:13:42Z",
          "updatedAt": "2025-05-22T22:13:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 9,
      "id": "PR_kwDONgvdIs6V1wo7",
      "title": "Reject unreasonably large \"p2c\" values",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/pull/9",
      "state": "MERGED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #1 ",
      "createdAt": "2025-05-12T13:33:45Z",
      "updatedAt": "2025-05-18T01:14:45Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "baseRefName": "main",
      "baseRefOid": "7e104a7798e8d375382967df02ca275e328dbebf",
      "headRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "headRefName": "mbj-p2c",
      "headRefOid": "fc8840a620791bf1486466bd334a7ee512ffd52c",
      "closedAt": "2025-05-18T01:14:45Z",
      "mergedAt": "2025-05-18T01:14:45Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "e624354927ac64871ba37a948891449791daf824"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONgvdIs6o5Cip",
          "commit": {
            "abbreviatedOid": "2a37ab4"
          },
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-12T14:47:37Z",
          "updatedAt": "2025-05-12T14:47:37Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "1M?\r\n\r\nhttps://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html",
              "createdAt": "2025-05-12T14:47:37Z",
              "updatedAt": "2025-05-12T14:47:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6pxR4T",
          "commit": {
            "abbreviatedOid": "af7a71e"
          },
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-05-17T12:29:19Z",
          "updatedAt": "2025-05-17T12:29:19Z",
          "comments": []
        },
        {
          "id": "PRR_kwDONgvdIs6pxrfq",
          "commit": {
            "abbreviatedOid": "2a37ab4"
          },
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-17T18:46:12Z",
          "updatedAt": "2025-05-17T18:46:12Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "I thought 1M was what was recommended as well -- is 10,000 too low?",
              "createdAt": "2025-05-17T18:46:12Z",
              "updatedAt": "2025-05-17T18:46:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6pxrlt",
          "commit": {
            "abbreviatedOid": "2a37ab4"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-17T18:48:14Z",
          "updatedAt": "2025-05-17T18:48:14Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "You're looking at outdated text.  Look at the files changed.  It's now 1.2M - double the NIST value.",
              "createdAt": "2025-05-17T18:48:14Z",
              "updatedAt": "2025-05-17T18:48:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6pyDNd",
          "commit": {
            "abbreviatedOid": "af7a71e"
          },
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-05-18T00:08:08Z",
          "updatedAt": "2025-05-18T00:08:23Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "I am looking at the files changed -- at least I think I am! If 1.2M then I'm fine. ",
              "createdAt": "2025-05-18T00:08:09Z",
              "updatedAt": "2025-05-18T00:08:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 10,
      "id": "PR_kwDONgvdIs6W-pJd",
      "title": "Mitigation for Compression DoS #3",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/pull/10",
      "state": "MERGED",
      "author": "dickhardt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "yaronf",
        "selfissued"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2025-05-21T02:04:15Z",
      "updatedAt": "2025-05-21T22:24:26Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "baseRefName": "main",
      "baseRefOid": "e624354927ac64871ba37a948891449791daf824",
      "headRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "headRefName": "Mitigation-for-Compression-DoS-#3",
      "headRefOid": "4f5f1478a28ecc2278d1f0f563bf649d7e3b0b5a",
      "closedAt": "2025-05-21T22:24:26Z",
      "mergedAt": "2025-05-21T22:24:26Z",
      "mergedBy": "dickhardt",
      "mergeCommit": {
        "oid": "6ed92926d8726fa357eb1d62aba88e1945520d73"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONgvdIs6qTP7J",
          "commit": {
            "abbreviatedOid": "79e83f0"
          },
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-21T10:28:55Z",
          "updatedAt": "2025-05-21T10:28:55Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Wrong RFC number, didn't check the section number.",
              "createdAt": "2025-05-21T10:28:55Z",
              "updatedAt": "2025-05-21T10:28:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qaxRi",
          "commit": {
            "abbreviatedOid": "4f5f147"
          },
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-05-21T21:15:21Z",
          "updatedAt": "2025-05-21T21:15:21Z",
          "comments": []
        },
        {
          "id": "PRR_kwDONgvdIs6qbNBL",
          "commit": {
            "abbreviatedOid": "4f5f147"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-05-21T22:16:15Z",
          "updatedAt": "2025-05-21T22:16:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 11,
      "id": "PR_kwDONgvdIs6W-xZP",
      "title": "Mitigation for JWT Format Confusion #2",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/pull/11",
      "state": "MERGED",
      "author": "dickhardt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "yaronf",
        "selfissued"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2025-05-21T02:29:15Z",
      "updatedAt": "2025-05-22T18:50:34Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "baseRefName": "main",
      "baseRefOid": "6ed92926d8726fa357eb1d62aba88e1945520d73",
      "headRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "headRefName": "Mitigation-for-JWT-Format-Confusion-#2",
      "headRefOid": "b66067420a6291a03f421debb09924fdeeab4f99",
      "closedAt": "2025-05-22T18:50:34Z",
      "mergedAt": "2025-05-22T18:50:34Z",
      "mergedBy": "dickhardt",
      "mergeCommit": {
        "oid": "8ef55aac26eeaaf99bf65ec66d7576ed35c5cf90"
      },
      "comments": [
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "@yaronf does Mike's suggestion (which I accepted resolve your concern?",
          "createdAt": "2025-05-21T22:29:11Z",
          "updatedAt": "2025-05-21T22:29:11Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "Please add a history entry for this change.",
          "createdAt": "2025-05-21T22:42:50Z",
          "updatedAt": "2025-05-21T22:42:50Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "> @yaronf does Mike's suggestion (which I accepted resolve your concern?\r\n\r\nYes it does.",
          "createdAt": "2025-05-22T05:34:53Z",
          "updatedAt": "2025-05-22T05:34:53Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDONgvdIs6qUfAP",
          "commit": {
            "abbreviatedOid": "b384f7d"
          },
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2025-05-21T12:20:02Z",
          "updatedAt": "2025-05-21T14:39:58Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I think we should mention that JSON Serialization is not compliant with the RFC. (To be clear, we should still mention it because it happens in reality).",
              "createdAt": "2025-05-21T12:20:02Z",
              "updatedAt": "2025-05-21T14:39:58Z"
            },
            {
              "originalPosition": 20,
              "body": "RECOMMENDED means SHOULD. Why not make it a MUST?",
              "createdAt": "2025-05-21T14:39:04Z",
              "updatedAt": "2025-05-21T14:39:58Z"
            },
            {
              "originalPosition": 20,
              "body": "```suggestion\r\nImplementations are RECOMMENDED to confirm if the JWT is a supported format before parsing the JWT. If the implementation only supports the compact format, the token will start with 'e' (ASCII 0x65) and if the implementation supports the JSON format, the token will start with '{' (ASCII 0x7B). \r\n```",
              "createdAt": "2025-05-21T14:39:45Z",
              "updatedAt": "2025-05-21T14:39:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qZbg4",
          "commit": {
            "abbreviatedOid": "b384f7d"
          },
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-21T18:47:09Z",
          "updatedAt": "2025-05-21T18:47:09Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I thought JSON serialization was a valid format. No?",
              "createdAt": "2025-05-21T18:47:09Z",
              "updatedAt": "2025-05-21T18:47:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qayQB",
          "commit": {
            "abbreviatedOid": "c2a21e8"
          },
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2025-05-21T21:17:28Z",
          "updatedAt": "2025-05-21T21:20:32Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "```suggestion\r\nImplementations MUST confirm that the JWT is a supported format before parsing the JWT. If the implementation only supports the compact format, the token will start with 'e' (ASCII 0x65) and if the implementation supports the JSON format, the token will start with '{' (ASCII 0x7B).\r\n```",
              "createdAt": "2025-05-21T21:17:28Z",
              "updatedAt": "2025-05-21T21:20:32Z"
            },
            {
              "originalPosition": 6,
              "body": "Quoting RFC 7519: \"JWTs are always represented using the JWS Compact Serialization or the JWE Compact Serialization.\"",
              "createdAt": "2025-05-21T21:20:23Z",
              "updatedAt": "2025-05-21T21:20:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qbPiM",
          "commit": {
            "abbreviatedOid": "b384f7d"
          },
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-21T22:24:05Z",
          "updatedAt": "2025-05-21T22:24:06Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "While 7519 defines a JWT and that it is the compact serialization, 7515 (JWS) and 7516 (JWE) both define a compact and JSON serialization, and the attack was a library that would take both of those serializations, which sortof makes sense as they are both defined in 7515 and 7516.\r\n\r\nhttps://datatracker.ietf.org/doc/html/rfc7515#section-7\r\n\r\nhttps://datatracker.ietf.org/doc/html/rfc7516#section-7\r\n\r\n@selfissued what are your thoughts?\r\n\r\n",
              "createdAt": "2025-05-21T22:24:05Z",
              "updatedAt": "2025-05-21T22:24:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qbQ3R",
          "commit": {
            "abbreviatedOid": "c2a21e8"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-21T22:26:51Z",
          "updatedAt": "2025-05-21T22:26:52Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nSome JWS implementations support both the Compact and JSON Serializations. While JWTs MUST use the Compact Serialization, if an application by mistake verifies a JWT using the JSON Serialization but extracts claims by parsing it as a JWT using the Compact Serialization (e.g., via string splitting), an attacker can craft a valid JSON JWS with a forged payload. This mismatch in format handling can lead to authentication bypass or impersonation.\r\n```",
              "createdAt": "2025-05-21T22:26:52Z",
              "updatedAt": "2025-05-21T22:26:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qbaX1",
          "commit": {
            "abbreviatedOid": "c2a21e8"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-21T22:39:44Z",
          "updatedAt": "2025-05-21T22:39:44Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "```suggestion\r\nImplementations MUST confirm the JWT is in a legal format while parsing it. Legal JWTs contain only the ASCII characters for letters, numbers, dash, underscore, and period.  Content with any other characters - especially braces and quotation marks - is not a JWT and MUST be rejected.\r\n```\r\n\r\nJWTs don't have to start with an \"e\" if there is leading space in the JSON before base64url-encoding.  Similarly, content using the JWS JSON Serialization doesn't have to start with \"{\" because it can have leading spaces.",
              "createdAt": "2025-05-21T22:39:44Z",
              "updatedAt": "2025-05-21T22:41:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qbdP4",
          "commit": {
            "abbreviatedOid": "b385151"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-21T22:46:32Z",
          "updatedAt": "2025-05-21T22:46:32Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "```suggestion\r\nImplementations MUST confirm the JWT is in a legal format while parsing it. Legal JWTs contain only the ASCII characters for letters, numbers, dash, underscore, and period.  Content with any other characters - especially braces and quotation marks - is not a JWT and MUST be rejected.\r\n```\r\n\r\nBecause of leading spaces being legal in JSON, neither of the \"e\" nor \"{\" statements is true.",
              "createdAt": "2025-05-21T22:46:32Z",
              "updatedAt": "2025-05-21T22:46:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qbdeQ",
          "commit": {
            "abbreviatedOid": "b384f7d"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-21T22:47:26Z",
          "updatedAt": "2025-05-21T22:47:26Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "My thoughts are in my change suggestion about JWTs containing only letters, numbers, dash, underscore, and period.",
              "createdAt": "2025-05-21T22:47:26Z",
              "updatedAt": "2025-05-21T22:47:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qb3Xk",
          "commit": {
            "abbreviatedOid": "c2a21e8"
          },
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T00:14:28Z",
          "updatedAt": "2025-05-22T00:14:28Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "That is a better check, thanks Mike.",
              "createdAt": "2025-05-22T00:14:28Z",
              "updatedAt": "2025-05-22T00:14:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs6qdaVt",
          "commit": {
            "abbreviatedOid": "b660674"
          },
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-05-22T05:35:07Z",
          "updatedAt": "2025-05-22T05:35:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 12,
      "id": "PR_kwDONgvdIs6XW2qK",
      "title": "Add missing items to doc history",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/pull/12",
      "state": "MERGED",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-05-23T09:36:27Z",
      "updatedAt": "2025-05-23T09:37:10Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "baseRefName": "main",
      "baseRefOid": "41f1359749ae6ab35b87f45ebdf8003b4713e801",
      "headRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "headRefName": "ys-hist-01",
      "headRefOid": "4bf8fc717549f569487786aed2fb095712e21ba6",
      "closedAt": "2025-05-23T09:37:09Z",
      "mergedAt": "2025-05-23T09:37:09Z",
      "mergedBy": "yaronf",
      "mergeCommit": {
        "oid": "639b52266ab174c41e750077f4193d362592e485"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 16,
      "id": "PR_kwDONgvdIs6fLXBt",
      "title": "Obsoletes RFC 8725",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/pull/16",
      "state": "MERGED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-07-16T12:35:25Z",
      "updatedAt": "2025-07-23T10:47:18Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "baseRefName": "main",
      "baseRefOid": "639b52266ab174c41e750077f4193d362592e485",
      "headRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "headRefName": "mbj-obsoletes",
      "headRefOid": "7e0e636e9c193fa166af19452689d76327883e1f",
      "closedAt": "2025-07-23T10:47:18Z",
      "mergedAt": "2025-07-23T10:47:18Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "300fa621e57ea9ccc6526404bef1358ae6d65bc6"
      },
      "comments": [
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "@selfissued IIRC, we're also supposed to say (in the intro?) why this obsoletes the RFC. Or does this only apply to \"Updates\"?",
          "createdAt": "2025-07-16T13:03:45Z",
          "updatedAt": "2025-07-16T13:03:45Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "I think you're correct, Yaron.  I believe that in IESG reviews, I've been asked to add this kind of information to the abstract before.\r\n\r\nI'll update the PR to do so.",
          "createdAt": "2025-07-16T13:12:20Z",
          "updatedAt": "2025-07-16T13:12:20Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDONgvdIs60UZNF",
          "commit": {
            "abbreviatedOid": "7e0e636"
          },
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-16T14:14:10Z",
          "updatedAt": "2025-07-16T14:14:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 21,
      "id": "PR_kwDONgvdIs6mKLVJ",
      "title": "Venue info and boilerplate directive",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/pull/21",
      "state": "MERGED",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Close #20 \r\n\r\n- Add venue section to YAML header with working group information\r\n- Replace manual BCP14 boilerplate text with {::boilerplate bcp14-tagged} directive\r\n- This implements the markdown magic requested in GitHub issue #20",
      "createdAt": "2025-08-31T12:23:23Z",
      "updatedAt": "2025-09-08T14:32:48Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "baseRefName": "main",
      "baseRefOid": "0f83811ec8a815d0998f7383825b8c5107dce279",
      "headRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "headRefName": "ys-20",
      "headRefOid": "094c81c9974c4bb6955e11c7b77e7b746736e807",
      "closedAt": "2025-09-08T14:32:48Z",
      "mergedAt": "2025-09-08T14:32:48Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "c214a94738d9b84bbb22616c96651d175fde3395"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONgvdIs6-i6ms",
          "commit": {
            "abbreviatedOid": "094c81c"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-09-08T14:31:54Z",
          "updatedAt": "2025-09-08T14:31:54Z",
          "comments": []
        },
        {
          "id": "PRR_kwDONgvdIs6-i7Fy",
          "commit": {
            "abbreviatedOid": "094c81c"
          },
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-09-08T14:32:26Z",
          "updatedAt": "2025-09-08T14:32:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 22,
      "id": "PR_kwDONgvdIs6mKNrI",
      "title": "New section: changes from RFC 8725",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/pull/22",
      "state": "MERGED",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #18 ",
      "createdAt": "2025-08-31T12:39:38Z",
      "updatedAt": "2025-09-22T14:03:45Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "baseRefName": "main",
      "baseRefOid": "0f83811ec8a815d0998f7383825b8c5107dce279",
      "headRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "headRefName": "ys-18",
      "headRefOid": "dbd617fe7da30fbe86b2b123c2b01dfc7cf37299",
      "closedAt": "2025-09-22T14:03:44Z",
      "mergedAt": "2025-09-22T14:03:44Z",
      "mergedBy": "yaronf",
      "mergeCommit": {
        "oid": "3b0b4460cdab628f057c23a8d9f9ee8f36f1c4e8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONgvdIs6-i7qn",
          "commit": {
            "abbreviatedOid": "2989a62"
          },
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-09-08T14:33:05Z",
          "updatedAt": "2025-09-08T14:33:05Z",
          "comments": []
        },
        {
          "id": "PRR_kwDONgvdIs6-i9KX",
          "commit": {
            "abbreviatedOid": "2989a62"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Let's add references to all the sections with the new content.",
          "createdAt": "2025-09-08T14:34:34Z",
          "updatedAt": "2025-09-08T14:34:34Z",
          "comments": []
        },
        {
          "id": "PRR_kwDONgvdIs7B5O_S",
          "commit": {
            "abbreviatedOid": "dbd617f"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-09-22T14:03:26Z",
          "updatedAt": "2025-09-22T14:03:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 23,
      "id": "PR_kwDONgvdIs6ptiYd",
      "title": "Dan Moore's comments - the editorial part",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/pull/23",
      "state": "MERGED",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-09-21T17:06:25Z",
      "updatedAt": "2025-09-29T14:27:27Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "baseRefName": "main",
      "baseRefOid": "c214a94738d9b84bbb22616c96651d175fde3395",
      "headRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "headRefName": "ys-14",
      "headRefOid": "1f05dd9df7e6b5ebc2c8662aed55ebf261f71d5d",
      "closedAt": "2025-09-29T14:27:27Z",
      "mergedAt": "2025-09-29T14:27:27Z",
      "mergedBy": "yaronf",
      "mergeCommit": {
        "oid": "dc7e59be77a63eafcf5d38610cb2fe8337d822cb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONgvdIs7DeSvu",
          "commit": {
            "abbreviatedOid": "1f05dd9"
          },
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-09-29T12:24:36Z",
          "updatedAt": "2025-09-29T12:24:36Z",
          "comments": []
        },
        {
          "id": "PRR_kwDONgvdIs7Dg1VV",
          "commit": {
            "abbreviatedOid": "1f05dd9"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-09-29T14:27:10Z",
          "updatedAt": "2025-09-29T14:27:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 25,
      "id": "PR_kwDONgvdIs6p07p7",
      "title": "More substantial edits by Dan Moore",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/pull/25",
      "state": "MERGED",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-09-22T12:12:43Z",
      "updatedAt": "2025-09-29T14:27:47Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "baseRefName": "main",
      "baseRefOid": "c214a94738d9b84bbb22616c96651d175fde3395",
      "headRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "headRefName": "ys-14b",
      "headRefOid": "88799023c6de7543dd0a01e094fa5bbebe12e5ed",
      "closedAt": "2025-09-29T14:27:47Z",
      "mergedAt": "2025-09-29T14:27:47Z",
      "mergedBy": "yaronf",
      "mergeCommit": {
        "oid": "81de00fa79af07a3787d78f4ff734c71e8b05ead"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONgvdIs7DgrO0",
          "commit": {
            "abbreviatedOid": "0e149a4"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-29T14:19:45Z",
          "updatedAt": "2025-09-29T14:19:45Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "```suggestion\r\nis required when using HMAC-SHA-256 to achieve FIPS-140 compliance. Rejecting inputs with a `p2c`\r\n```",
              "createdAt": "2025-09-29T14:19:45Z",
              "updatedAt": "2025-09-29T14:19:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs7DgsNi",
          "commit": {
            "abbreviatedOid": "9a364d2"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-09-29T14:20:41Z",
          "updatedAt": "2025-09-29T14:20:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDONgvdIs7DgtPu",
          "commit": {
            "abbreviatedOid": "9a364d2"
          },
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-09-29T14:21:44Z",
          "updatedAt": "2025-09-29T14:21:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 26,
      "id": "PR_kwDONgvdIs6uuIvW",
      "title": "Fix GitHub link format in draft document",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/pull/26",
      "state": "MERGED",
      "author": "yaronf",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-10-20T22:07:38Z",
      "updatedAt": "2025-10-21T07:17:19Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "baseRefName": "main",
      "baseRefOid": "9619fc348fdb468b7c628069a3347fffecd01930",
      "headRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "headRefName": "yaronf-patch-1",
      "headRefOid": "ac286003d3f0fc6f5ac87a36b8a9c01115f25901",
      "closedAt": "2025-10-21T07:17:18Z",
      "mergedAt": "2025-10-21T07:17:18Z",
      "mergedBy": "yaronf",
      "mergeCommit": {
        "oid": "64ebc8251f951c87a168ddd6c14da09196d903eb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONgvdIs7IKPeI",
          "commit": {
            "abbreviatedOid": "ac28600"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-10-20T22:31:19Z",
          "updatedAt": "2025-10-20T22:31:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 27,
      "id": "PR_kwDONgvdIs6yKvh_",
      "title": "Incorporate Aaron Parecki's review suggestions",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/pull/27",
      "state": "MERGED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #17\r\n\r\n",
      "createdAt": "2025-11-07T15:50:44Z",
      "updatedAt": "2025-11-07T17:48:03Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "baseRefName": "main",
      "baseRefOid": "64ebc8251f951c87a168ddd6c14da09196d903eb",
      "headRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "headRefName": "mbj-aaron",
      "headRefOid": "e8f63bd377ba72e4c999252d8e80ae83ec73a7d7",
      "closedAt": "2025-11-07T17:48:03Z",
      "mergedAt": "2025-11-07T17:48:02Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "2ab07d7bfac2825b712680d303a6b2f12b6afb53"
      },
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Thanks. I reviewed the changes and I don't see these two of my earlier comments addressed in this:\r\n\r\n* There is still a mention of the \"none\" algorithm being acceptable over TLS\r\n* The \"Explicit Typing\" section still starts with the vague \"Sometimes, one kind of JWT can be confused for another\"",
          "createdAt": "2025-11-07T16:50:20Z",
          "updatedAt": "2025-11-07T16:50:20Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, Aaron.  \r\n\r\n> There is still a mention of the \"none\" algorithm being acceptable over TLS\r\n\r\nI'll look at the \"none\" text and update the PR.  Sorry I missed that one!\r\n\r\n> The \"Explicit Typing\" section still starts with the vague \"Sometimes, one kind of JWT can be confused for another\"\r\n\r\nThe new paragraph after this one, giving an example of possible confusion, was intended to do what you asked in your review, which was:\r\n\r\n> This is kind of vague and would benefit from more explicit examples.\r\n\r\nSo I'd either ask that you check off the last request as completed or provide more input as to particular additional text changes you'd like.\r\n\r\nThanks again!",
          "createdAt": "2025-11-07T17:29:28Z",
          "updatedAt": "2025-11-07T17:29:28Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "@aaronpk, I deleted the text saying that the use of \"alg\":\"none\" can be acceptable when transmitting JWTs over TLS.  Please re-review.",
          "createdAt": "2025-11-07T17:39:33Z",
          "updatedAt": "2025-11-07T17:39:33Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDONgvdIs7MvXg4",
          "commit": {
            "abbreviatedOid": "cfd3a6d"
          },
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2025-11-07T16:17:05Z",
          "updatedAt": "2025-11-07T16:24:13Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "```suggestion\nAs one example, OAuth 2.0 authorization server \"issuer\" values {{RFC8414}}\n```",
              "createdAt": "2025-11-07T16:17:05Z",
              "updatedAt": "2025-11-07T16:24:13Z"
            },
            {
              "originalPosition": 66,
              "body": "```suggestion\nIn the OAuth context, {{Section 4.15 of RFC9700}} discusses the possibility of\n```",
              "createdAt": "2025-11-07T16:19:33Z",
              "updatedAt": "2025-11-07T16:24:13Z"
            },
            {
              "originalPosition": 80,
              "body": "```suggestion\nWhen such an allowlist is not available, the authorization server SHOULD check what a hostname resolves to\n```\n\nThe requirements here are very onerous and they're not really needed if people use an allowlist.",
              "createdAt": "2025-11-07T16:22:06Z",
              "updatedAt": "2025-11-07T16:24:13Z"
            },
            {
              "originalPosition": 97,
              "body": "```suggestion\nwhen the validation rules for both kinds of JWTs include validating the \"typ\" values\n```",
              "createdAt": "2025-11-07T16:23:43Z",
              "updatedAt": "2025-11-07T16:24:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs7Mw7Tw",
          "commit": {
            "abbreviatedOid": "aa68ce7"
          },
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-11-07T17:32:11Z",
          "updatedAt": "2025-11-07T17:32:11Z",
          "comments": []
        },
        {
          "id": "PRR_kwDONgvdIs7MxF1v",
          "commit": {
            "abbreviatedOid": "d3d0e41"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-07T17:40:50Z",
          "updatedAt": "2025-11-07T17:40:50Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "```suggestion\nWhen two different uses of JWTs share a common set of claims, one kind of JWT can be confused for another. If a particular\n```",
              "createdAt": "2025-11-07T17:40:50Z",
              "updatedAt": "2025-11-07T17:40:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs7MxGhv",
          "commit": {
            "abbreviatedOid": "d3d0e41"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-07T17:41:21Z",
          "updatedAt": "2025-11-07T17:41:21Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "The additional paragraph below is definitely helpful. This is more the kind of thing I was looking for in the intro.",
              "createdAt": "2025-11-07T17:41:21Z",
              "updatedAt": "2025-11-07T17:41:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs7MxOAG",
          "commit": {
            "abbreviatedOid": "e8f63bd"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-11-07T17:47:24Z",
          "updatedAt": "2025-11-07T17:47:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 28,
      "id": "PR_kwDONgvdIs6yLk1z",
      "title": "Acknowledge contributors to rfc8725bis",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/pull/28",
      "state": "MERGED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #13 ",
      "createdAt": "2025-11-07T16:54:56Z",
      "updatedAt": "2025-11-07T17:51:13Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "baseRefName": "main",
      "baseRefOid": "2ab07d7bfac2825b712680d303a6b2f12b6afb53",
      "headRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "headRefName": "mbj-acknowledgements",
      "headRefOid": "b5cfe3ab320ede88ffc2698088c6b87f444c4f6f",
      "closedAt": "2025-11-07T17:51:13Z",
      "mergedAt": "2025-11-07T17:51:13Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "944e1639ce316d3ea95c89117222ee6acc9ac7b6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONgvdIs7MwX34",
          "commit": {
            "abbreviatedOid": "2741924"
          },
          "author": "panva",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-11-07T17:02:31Z",
          "updatedAt": "2025-11-07T17:02:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 32,
      "id": "PR_kwDONgvdIs640HfJ",
      "title": "Describe relationship between explicit typing and JWTs not already employing it",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/pull/32",
      "state": "MERGED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #30",
      "createdAt": "2025-12-15T01:34:01Z",
      "updatedAt": "2025-12-15T15:52:31Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "baseRefName": "main",
      "baseRefOid": "944e1639ce316d3ea95c89117222ee6acc9ac7b6",
      "headRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "headRefName": "mbj-explicit-typing",
      "headRefOid": "aeec60582e960c611eb33e27ed28fb19d70e5c43",
      "closedAt": "2025-12-15T15:52:31Z",
      "mergedAt": "2025-12-15T15:52:31Z",
      "mergedBy": "yaronf",
      "mergeCommit": {
        "oid": "d0f9cc7d6b701c25c85be787789e6e7b3200245e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONgvdIs7VT2rL",
          "commit": {
            "abbreviatedOid": "3785502"
          },
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-12-15T15:16:28Z",
          "updatedAt": "2025-12-15T15:16:28Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\nan updated implementation receiving it requires the explicit type,\n```",
              "createdAt": "2025-12-15T15:16:28Z",
              "updatedAt": "2025-12-15T15:16:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs7VT4U-",
          "commit": {
            "abbreviatedOid": "9145238"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-12-15T15:17:58Z",
          "updatedAt": "2025-12-15T15:17:58Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\nthen it MUST be the expected explicit type, is not a breaking change.\n```",
              "createdAt": "2025-12-15T15:17:58Z",
              "updatedAt": "2025-12-15T15:17:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONgvdIs7VT5eR",
          "commit": {
            "abbreviatedOid": "aeec605"
          },
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-12-15T15:18:58Z",
          "updatedAt": "2025-12-15T15:18:58Z",
          "comments": []
        },
        {
          "id": "PRR_kwDONgvdIs7VT6ye",
          "commit": {
            "abbreviatedOid": "aeec605"
          },
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-12-15T15:20:16Z",
          "updatedAt": "2025-12-15T15:20:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 33,
      "id": "PR_kwDONgvdIs65-ITI",
      "title": "Add note about implementations that removed support for \"zip\"",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/pull/33",
      "state": "MERGED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #31 ",
      "createdAt": "2025-12-20T20:40:52Z",
      "updatedAt": "2026-01-12T15:18:04Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "baseRefName": "main",
      "baseRefOid": "d0f9cc7d6b701c25c85be787789e6e7b3200245e",
      "headRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "headRefName": "mbj-compression",
      "headRefOid": "1a22aa097c1cdab3aab7c599f5906ebd4d1189a4",
      "closedAt": "2026-01-12T15:18:04Z",
      "mergedAt": "2026-01-12T15:18:03Z",
      "mergedBy": "yaronf",
      "mergeCommit": {
        "oid": "fce1a611d0b90ea993b2159c635b49b1cc60f56e"
      },
      "comments": [
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "Actually, the BCP doesn't update JWE [RFC 7516]. It's not within our remit to make breaking changes to a spec in another working group. That would need to be done by new spec work in the JOSE working group, with consensus of that working group. It is within our scope to recommend that problematic features not be used.",
          "createdAt": "2025-12-21T17:32:17Z",
          "updatedAt": "2025-12-21T17:34:35Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "Checking in on where we are at on this. The updates look good to me. @bc-pi now is the time to make any additional suggestions!",
          "createdAt": "2026-01-07T12:12:51Z",
          "updatedAt": "2026-01-07T12:12:51Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "body": "While I understand the motivation for the paragraph that describes the interop issues with libraries that removed support for compression, I'm afraid that this paragraph significantly dilutes our message. As a BCP we are explaining why compression is problematic, let's keep it at that and have developers draw their own conclusions on pros and cons of supporting this functionality.\r\n\r\nSo, I suggest to retain the added reference but remove the compatibility paragraph. ",
          "createdAt": "2026-01-09T13:09:49Z",
          "updatedAt": "2026-01-09T13:09:49Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDONgvdIs7WqDWi",
          "commit": {
            "abbreviatedOid": "599fae8"
          },
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-12-20T22:14:57Z",
          "updatedAt": "2025-12-20T22:14:57Z",
          "comments": []
        },
        {
          "id": "PRR_kwDONgvdIs7WrlCu",
          "commit": {
            "abbreviatedOid": "599fae8"
          },
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I disagree with the premise here: the BCP formally Updates 7519 (and would Update 7516 if we asked for it), and so I don't think we are committed to retain every last feature if we believe it raises security issues.\n\nWe are pointing out a security problem with systems and libraries, and I don't think the position \"SHOULD NOT compress but still MUST support zip\" is consistent.",
          "createdAt": "2025-12-21T15:02:10Z",
          "updatedAt": "2025-12-21T15:02:10Z",
          "comments": []
        },
        {
          "id": "PRR_kwDONgvdIs7Yo1Tm",
          "commit": {
            "abbreviatedOid": "599fae8"
          },
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2026-01-07T12:10:35Z",
          "updatedAt": "2026-01-07T12:10:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 34,
      "id": "PR_kwDONgvdIs65-PeB",
      "title": "Add informative reference to draft-ietf-jose-deprecate-none-rsa15",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-rfc8725bis/pull/34",
      "state": "MERGED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Adds an informative reference to draft-ietf-jose-deprecate-none-rsa15 since this was requested by multiple WGLC reviewers.\r\n\r\nFixes #29",
      "createdAt": "2025-12-20T21:17:11Z",
      "updatedAt": "2025-12-23T17:27:48Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "baseRefName": "main",
      "baseRefOid": "d0f9cc7d6b701c25c85be787789e6e7b3200245e",
      "headRepository": "oauth-wg/draft-ietf-oauth-rfc8725bis",
      "headRefName": "mbj-alg-none",
      "headRefOid": "be5e2516f73bef600015784e7c524f0a68878c29",
      "closedAt": "2025-12-23T17:27:48Z",
      "mergedAt": "2025-12-23T17:27:47Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "92d45a691e791ee8d71cad9d63f0ea0e40f40dee"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONgvdIs7WqJMc",
          "commit": {
            "abbreviatedOid": "be5e251"
          },
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-12-20T23:37:24Z",
          "updatedAt": "2025-12-20T23:37:24Z",
          "comments": []
        },
        {
          "id": "PRR_kwDONgvdIs7WrkTs",
          "commit": {
            "abbreviatedOid": "be5e251"
          },
          "author": "yaronf",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-12-21T14:54:03Z",
          "updatedAt": "2025-12-21T14:54:03Z",
          "comments": []
        },
        {
          "id": "PRR_kwDONgvdIs7Wrk05",
          "commit": {
            "abbreviatedOid": "be5e251"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-12-21T14:59:58Z",
          "updatedAt": "2025-12-21T14:59:58Z",
          "comments": []
        }
      ]
    }
  ]
}